#!/usr/bin/perl -w

use Data::Dumper;

# Find examples of functions in the test
# files and make help entries out of them


@infiles = (
    './tests/rtest_mixima.mac',
    './tests/rtest_table.mac',
    './tests/rtest_findroot.mac',
    './tests/rtest_matrix.mac',
    './tests/rtest_sets.mac',
    './tests/rtest_incr_decr.mac',
    './tests/rtest_combinatorics.mac',
    './tests/rtest_expressions.mac',
    './tests/rtest_assign.mac',
    './tests/rtest_flow_control.mac',
    './tests/rtest_list.mac',
    './tests/rtest_expressions.mac',
    './tests/rtest_function.mac',
    './tests/rtest_nintegrate.mac',
    './tests/rtest_primes.mac',
    './tests/rtest_special_functions.mac'
);

$Debug = 0;

sub deb {
    my ($c) = @_;
    print STDERR "$c\n" if $Debug == 1;
}


sub strip_spaces {

    my($s) = @_;

    $s =~ s/^\s*//;
    

    $s =~ s/\s*$//;

    return $s;
}

sub escape_string {
    my($s) = @_;
    $s =~ s/\"/\\\"/g;
    return $s;
}


sub fixup_string {
    my($s) = @_;
    return escape_string(strip_spaces($s));
}


sub parse_file {

    my($file) = @_;
    open IH , "<$file" or die "Can't open '$file' for reading";
    my $gotex = 0;
    my ($thisex, $exname, $com,$res,$line);
    while ($line = <IH>) {
        $line = strip_spaces($line);
#        print $line;
        chomp($line);
        next if $line =~ /^\s*$/;
        next if $line =~ /^\s*\/\*\s*$/;
        next if $line =~ /^\s*\*\/\s*$/;
        if ( $line =~ /\/*\s+endex/ ) {
            deb (" endex: type:$extype, gotex: $gotex") if $Debug == 1;
            if ($gotex >1) {
                chomp($com);
                chomp($res);
                $thisex->{com} = $com;
                $thisex->{res} = $res;
                $Examples{$exname} = [] unless exists  $Examples{$exname};
                push @{$Examples{$exname}}, $thisex;
                deb(" recording example: name:$exname");
                $gotex = 0;
            }
            else {
                $gotex = 0;                
            } 
#            next;
        }
        if ( ($line =~ /\/\*\s+ex\s+(\S+)\s+(\S+)/ or eof(IH) )) {
            if ( $gotex != 0) {
                chomp($com);
                chomp($res);
                $thisex->{com} = $com;
                $thisex->{res} = $res;
                $Examples{$exname} = [] unless exists  $Examples{$exname};
                push @{$Examples{$exname}}, $thisex;
                deb(" recording example: name:$exname");
            }
            $gotex = 1;
            $extype = $1;
            $exname = $2;
            $thisex = { name => $exname };
            $thisex->{type} = $extype;
            #                print "$exname: $extype\n";
            $com = '';
            $res = '';
            deb("got example: name:$exname, type:$extype");
        }
        elsif ($gotex > 0 ) {
            my ($gmma,$gcom,$gres) = (0,0,0);
            if ( $line =~ /\/\*\s+cm\s+(.+)\*\// ) {
                $thisex->{comments} = [] unless exists  $thisex->{comments};
                push @{$thisex->{comments}}, fixup_string($1);
                deb(" got comment: " . fixup_string($1) );
                next;
            }
            if ( $line =~ /\/\*\s+mma\s+(.+)\*\// ) {
                $thisex->{mma} = [] unless exists  $thisex->{mma};
                push @{$thisex->{mma}}, fixup_string($1);
                deb(" got mma: " . fixup_string($1) );
                $gmma = 1;
                $gotex++;
                next;
            }
            if ( $gotex == 1 ) {
                $com .= fixup_string($line) . "\n";
            }
            else {
                $res .= fixup_string($line) . "\n";            
            }
            if ( $line =~ /\;$/  or $gmma == 1) {
                $gotex++;
                $gotex++ unless $extype eq 'ok'; # there is no result for broken examples
                deb(" gotex now $gotex");
            }
        }
    }
}

#  (help-item-init "SomeFunc")
# (help-item-add-example "SomeFunc"
#                       (list :mma "SomeFunc[y,z,{1,10}]"
#                            :maxin "SomeFunc(x,q,x,[1,10]);"
#                             :maxout "[1,2,4] cat dog"))

sub print_lisp_calls {
    my $istream;
    local $/ = undef;
    open $istream , '<', "./compatibility/mixdoc.in.lisp" or die "Can't find ./compatibility/mixdoc.in.lisp";
    my $md = <$istream>;
    print "; DO NOT EDIT THIS FILE. EDIT mixdoc.in.lisp\n";
    print $md;
    print "(clrhash *mix-help-hash*)\n";
    foreach my $key (keys %Examples  ) {
        print "(help-item-init \"$key\")\n\n";
        foreach my $ex ( reverse(@{$Examples{$key}}) ) {
            print '(help-item-add-example "' . $key .  '"' . "\n  (list \n";
            print "  :type " . '"' .  $ex->{type} . '"' .  "\n" if exists $ex->{type};
            print "  :comments " . '"' . join("\n " , @{$ex->{comments}}) . '"'.  "\n" if exists $ex->{comments};
            print "  :maxin " . '"' .  $ex->{com} . '"' .  "\n" if exists $ex->{com};
            print "  :maxout " . '"' , $ex->{res} . '"' .  "\n" if exists $ex->{res};
            print "  :mma " . '"' . join("\n " , @{$ex->{mma}}) . '"'.  "\n" if exists $ex->{mma};
            print " ))\n\n";
        }
    }
}
    

foreach my $file (@infiles) {
    parse_file($file);
}

print_lisp_calls();
#print Dumper(%Examples);
