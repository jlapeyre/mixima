; DO NOT EDIT THIS FILE. EDIT mixdoc.in.lisp
(defvar *mix-help-hash*  (make-hash-table :test #'equal  ))

;(load "./function_list.lisp")

;(defun dump-help-db ()
;  (maphash #'print-hash-entry *mix-help-hash*))

(defun get-hash-keys (hash)
  (let ((klist ()))
    (maphash (lambda (x y) (setf klist (cons x klist))) hash)
    klist))

(defun print-list-of-items (items)
    (format t "件爆赴夯窿"
            (sort items #'string-lessp))
    (format t "%"))

;(defun print-help-items ()
;  (print-list-of-items (get-hash-keys *mix-help-hash*)))

(defun print-help-items ()
  (print-list-of-items mixima-function-list))

(defun print-searched-help-items (str)
  (print-list-of-items (search-for-items mixima-function-list str)))

;(defun print-searched-help-items (str)
;  (print-list-of-items (search-for-items (get-hash-keys *mix-help-hash*) str)))

; return output list filtered by string str
(defun search-for-items (items str)
 (remove-if (complement #'(lambda (x) (search str x :test #'char-equal))) items))

(defun get-item (key)
  (gethash key *mix-help-hash*))

(defun set-item (key entry)
  (setf (gethash key *mix-help-hash*) entry))

(defun init-hash-item (key table)
  (setf (gethash key table)
        (list :name key :examples nil)))

(defun help-item-init (key)
  (init-hash-item key *mix-help-hash*))

(defun help-item-add-example (key example &aux entry)
  (setf entry (get-item key))
  (setf (getf entry  :examples) (cons example (getf entry :examples)))
  (set-item key entry))

(defun print-one-example (example &aux mma maxin maxout comments type)
  (setf comments (getf example :comments))
  (setf type (getf example :type))
;  (if type (format t "type: a%" type))
  (if comments (format t "a%" comments))
  (setf mma (getf example :mma))
  (if (and mma (not (equalp mma ""))) (format t   "Mma   : a%" mma))
  (setf maxin (getf example :maxin))
  (if (and maxin (not (equalp maxin ""))) (format t "maxima: a%" maxin))
  (setf maxout (getf example :maxout))
  (if (and maxout (not (equalp maxout ""))) (format t "output: a%" maxout))
  (format t "---------------------------%"))

(defun print-examples (examples &key exclude include &aux type )
  (mapcar (lambda (x)
            (setf type (getf x :type))
            (cond ( (and include (not (equalp type include))))
                  ( (and exclude (equalp type exclude)))
                  ( t
                    (print-one-example x)))) examples)
  t)

(defun print-item-examples (item-name &key exclude include descr  &aux entry)
  (setf entry  (get-item item-name))
  (format t "%%---------------------------------%")
  (format t "-- Function -- a%" item-name)
  (format t "a%" descr)
  (format t     "---------------------------------%%")
  (print-examples (getf entry :examples) :exclude exclude :include include   ))


(defun count-item-types (item-name &key include exclude &aux entry examples type)
  (setf entry  (get-item item-name))
  (setf examples (getf entry :examples))
  (count-if  (lambda (e)
           (setq type (getf e :type))
           (cond ( (and include (not (equalp type include))) nil)
                 ( (and exclude (equalp type exclude)) nil)
                 ( t  t))) examples))


(defun print-item-bad-examples (item-name )
  (if ( >  (count-item-types item-name :exclude "ok") 0)
      (print-item-examples item-name :exclude  "ok" :descr "-- Unimplemented or broken Examples --")))

(defun print-item-good-examples (item-name )
  (if ( >  (count-item-types item-name :include "ok") 0)
      (print-item-examples item-name :include  "ok" :descr "-- Working Examples --")))


; this damn function is somewhere else ,  too
; Only switch the case if it is not mixed
(defun switch-case-maybe (str &aux upstr downstr)
  (setf upstr    (string-upcase str))
  (setf downstr  (string-downcase str))
  (cond ( (equal str upstr) downstr)
        ( (equal str downstr) upstr)
        ( t str )))

; was this causing a problem ?
(in-package :maxima)

#|> Function mixFuncs |#
; search for names of compatibility functions matching
; a string
(defmfun |$mixFuncs| ( &optional (search-str "")  )
  (if (symbolp search-str) (setf search-str (string (stripdollar search-str))))
  (print-searched-help-items search-str)
  t)

#|> Function mixDoc |#
; Example: mixDoc(Table)
(defmfun |$mixDoc| ( item &optional type )
  (if (not (stringp item)) (setq item (switch-case-maybe (subseq (format nil "a" item) 1 ))))
;  (format t "a%" item)
  (cond ( (or (eq type '$GOOD) (eq nil type))
          (print-item-good-examples item))
        ( (eq type '$BAD)
          (print-item-bad-examples item)))
  t)
        
(clrhash *mix-help-hash*)
(help-item-init "SubtractFrom")

(help-item-add-example "SubtractFrom"
  (list 
  :type "ok"
  :maxin ""
  :maxout "SubtractFrom(a,r);
r*z-r ;"
  :mma "SubtractFrom[a,r]"
 ))

(help-item-init "DiagonalMatrix")

(help-item-add-example "DiagonalMatrix"
  (list 
  :type "ok"
  :maxin ""
  :maxout "DiagonalMatrix([a,b,c],2);
[[0,0,a,0,0],[0,0,0,b,0],[0,0,0,0,c],[0,0,0,0,0],[0,0,0,0,0]] ;"
  :mma "DiagonalMatrix[{a,b,c},2]"
 ))

(help-item-add-example "DiagonalMatrix"
  (list 
  :type "br"
  :maxin ""
  :maxout ""
  :mma "DiagonalMatrix[{1, 2, 3, 4, 5}, 0, 3]"
 ))

(help-item-add-example "DiagonalMatrix"
  (list 
  :type "br"
  :maxin ""
  :maxout ""
  :mma "DiagonalMatrix[{1, 2, 3}, 0, 5]"
 ))

(help-item-add-example "DiagonalMatrix"
  (list 
  :type "ok"
  :maxin ""
  :maxout "DiagonalMatrix([a,b],-1);
[[0,0,0],[a,0,0],[0,b,0]] ;"
  :mma "DiagonalMatrix[{a,b},-1]"
 ))

(help-item-add-example "DiagonalMatrix"
  (list 
  :type "ok"
  :maxin ""
  :maxout "DiagonalMatrix([a,b],1);
[[0,a,0],[0,0,b],[0,0,0]] ;"
  :mma "DiagonalMatrix[{a,b},1]"
 ))

(help-item-add-example "DiagonalMatrix"
  (list 
  :type "ok"
  :maxin ""
  :maxout "DiagonalMatrix([a,b,c]);
[[a,0,0],[0,b,0],[0,0,c]] ;"
  :mma "DiagonalMatrix[{a,b,c}]"
 ))

(help-item-init "AtomQ")

(help-item-add-example "AtomQ"
  (list 
  :type "ok"
  :maxin "AtomQ(3+%i);"
  :maxout "true;"
 ))

(help-item-add-example "AtomQ"
  (list 
  :type "ok"
  :maxin "AtomQ(1/10);"
  :maxout "true;"
 ))

(help-item-add-example "AtomQ"
  (list 
  :type "ok"
  :maxin "AtomQ(123456);"
  :maxout "true;"
 ))

(help-item-add-example "AtomQ"
  (list 
  :type "ok"
  :maxin "AtomQ(\"string\");"
  :maxout "true;"
 ))

(help-item-add-example "AtomQ"
  (list 
  :type "ok"
  :maxin "AtomQ(x);"
  :maxout "true;"
 ))

(help-item-add-example "AtomQ"
  (list 
  :type "ok"
  :maxin "AtomQ(1 + 2*%i);"
  :maxout "true;"
 ))

(help-item-add-example "AtomQ"
  (list 
  :type "ok"
  :maxin "AtomQ(1.23);"
  :maxout "true;"
 ))

(help-item-add-example "AtomQ"
  (list 
  :type "ok"
  :maxin "AtomQ(ThisIsAnAtom);"
  :maxout "true;"
 ))

(help-item-add-example "AtomQ"
  (list 
  :type "ok"
  :maxin "AtomQ(\"this is an atom\");"
  :maxout "true;"
 ))

(help-item-add-example "AtomQ"
  (list 
  :type "ok"
  :maxin "AtomQ(22/7);"
  :maxout "true;"
 ))

(help-item-add-example "AtomQ"
  (list 
  :type "ok"
  :maxin "block([e : x + 22/7],
AtomQ(e));"
  :maxout "false;"
 ))

(help-item-init "ReplaceAll")

(help-item-add-example "ReplaceAll"
  (list 
  :type "br"
  :comments "wrong answer. We are supposed to stop after first success."
  :maxin ""
  :maxout "ReplaceAll([a,b,c],[Rule(a,b),Rule(b,d)]);
[d,d,c] ;"
  :mma "{a,b,c}./.{a>->b,b>->d}"
 ))

(help-item-add-example "ReplaceAll"
  (list 
  :type "br"
  :comments "This translation done by hand. The precedence or assoc is wrong"
  :maxin ""
  :maxout "ReplaceAll( ReplaceAll([a,b,c], Rule(a,b) ),Rule(b,d));
[d,d,c] ;"
  :mma "{a,b,c} /. a -> b /. b -> d"
 ))

(help-item-add-example "ReplaceAll"
  (list 
  :type "ok"
  :maxin ""
  :maxout "ReplaceAll(x,[Rule(x,1),Rule(x,3),Rule(x,7)]);
1 ;"
  :mma "x./.{x>->1,x>->3,x>->7}"
 ))

(help-item-add-example "ReplaceAll"
  (list 
  :type "ok"
  :comments "Cos and Sin don't work because Sin will first evaluate to sin"
  :maxin ""
  :maxout "ReplaceAll(sin(x),Rule(sin,cos));
cos(x) ;"
  :mma "Sin[x]./.Sin>->Cos"
 ))

(help-item-add-example "ReplaceAll"
  (list 
  :type "ok"
  :maxin ""
  :maxout "ReplaceAll([x,(x^2),y,z],Rule(x,[a,b]));
[[a,b],[a^2,b^2],y,z] ;"
  :mma "{x,x^2,y,z}./.x>->{a,b}"
 ))

(help-item-add-example "ReplaceAll"
  (list 
  :type "ok"
  :maxin ""
  :maxout "ReplaceAll([x,(x^2),y,z],Rule(x,a));
[a,a^2,y,z] ;"
  :mma "{x,x^2,y,z} ./ x->a"
 ))

(help-item-add-example "ReplaceAll"
  (list 
  :type "br"
  :comments "wrong answer. We are supposed to stop after first success."
  :maxin ""
  :maxout "ReplaceAll([a,b,c],[Rule(a,b),Rule(b,d)]);
[d,d,c] ;"
  :mma "{a,b,c}./.{a>->b,b>->d}"
 ))

(help-item-add-example "ReplaceAll"
  (list 
  :type "br"
  :comments "This translation done by hand. The precedence or assoc is wrong"
  :maxin ""
  :maxout "ReplaceAll( ReplaceAll([a,b,c], Rule(a,b) ),Rule(b,d));
[d,d,c] ;"
  :mma "{a,b,c} /. a -> b /. b -> d"
 ))

(help-item-add-example "ReplaceAll"
  (list 
  :type "ok"
  :maxin ""
  :maxout "ReplaceAll(x,[Rule(x,1),Rule(x,3),Rule(x,7)]);
1 ;"
  :mma "x./.{x>->1,x>->3,x>->7}"
 ))

(help-item-add-example "ReplaceAll"
  (list 
  :type "ok"
  :comments "Cos and Sin don't work because Sin will first evaluate to sin"
  :maxin ""
  :maxout "ReplaceAll(sin(x),Rule(sin,cos));
cos(x) ;"
  :mma "Sin[x]./.Sin>->Cos"
 ))

(help-item-add-example "ReplaceAll"
  (list 
  :type "ok"
  :maxin ""
  :maxout "ReplaceAll([x,(x^2),y,z],Rule(x,[a,b]));
[[a,b],[a^2,b^2],y,z] ;"
  :mma "{x,x^2,y,z}./.x>->{a,b}"
 ))

(help-item-add-example "ReplaceAll"
  (list 
  :type "ok"
  :maxin ""
  :maxout "ReplaceAll([x,(x^2),y,z],Rule(x,a));
[a,a^2,y,z] ;"
  :mma "{x,x^2,y,z} ./ x->a"
 ))

(help-item-init "Permutations")

(help-item-add-example "Permutations"
  (list 
  :type "ok"
  :comments "Not really correct. The elements are in a different order."
  :maxin ""
  :maxout "Permutations([x,(x^2),(x+1)]);
[[x,x+1,x^2],[x,x^2,x+1],[x+1,x,x^2],[x+1,x^2,x],[x^2,x,x+1],[x^2,x+1,x]] ;"
  :mma "Permutations[{x,x^2,x+1}]"
 ))

(help-item-add-example "Permutations"
  (list 
  :type "ok"
  :comments "If maxima sets are passed, then duplicates don't count in input."
  :maxin "Permutations({a, a, b});"
  :maxout "{[a, b], [b, a]};"
 ))

(help-item-add-example "Permutations"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Permutations([a,a,b]);
[[a, a, b], [a, b, a], [b, a, a]] ;"
  :mma "Permutations[{a,a,b}]"
 ))

(help-item-add-example "Permutations"
  (list 
  :type "br"
  :maxin ""
  :maxout ""
  :mma "Permutations[{a, b, c, d}, {3}]"
 ))

(help-item-add-example "Permutations"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Permutations([a,b,c]);
[[a, b, c], [a, c, b], [b, a, c], [b, c, a], [c, a, b], [c, b, a]] ;"
  :mma "Permutations[{a,b,c}]"
 ))

(help-item-init "AddTo")

(help-item-add-example "AddTo"
  (list 
  :type "ok"
  :maxin ""
  :maxout "AddTo(a,r);
(r*z-r)/r+r ;"
  :mma "AddTo[a,r]"
 ))

(help-item-init "Sum")

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :comments "slightly different form than Mma"
  :maxin "factor(Sum(((i^3)+((i+3)^5)),[i,1,n]));"
  :maxout "n*(n^5+21*n^4+184*n^3+843*n^2+2161*n+2940)/6;"
 ))

(help-item-add-example "Sum"
  (list 
  :type "br"
  :comments "untrapped lisp error !"
  :maxin "Sum((i*j),[i,0,n],i);"
  :maxout ""
 ))

(help-item-add-example "Sum"
  (list 
  :type "br"
  :comments "untrapped lisp error !"
  :maxin "Sum((i*j),i,j);"
  :maxout ""
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :maxin "Sum(i,[i,n]);"
  :maxout "(n^2+n)/2;"
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :comments "possibly different from Mma result."
  :maxin "Sum(1/(1 + i + j)^3, [i, Infinity], [j, Infinity]);"
  :maxout "'sum(zeta(3)-gen_harmonic_number(3,i+1),i,1,inf);"
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :comments "different from Mma result."
  :maxin "Sum((((i^2)+1)^-1),[i,(-1*inf),inf]);"
  :maxout "-%i*(psi[0](%i+1)+%gamma)/2-%i*(psi[0](%i)+%gamma)/2
+%i*(psi[0](-%i)+%gamma)/2
+%i*(psi[0](1-%i)+%gamma)/2;"
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :maxin "Sum(((i^2)^-1),[i,inf]);"
  :maxout "%pi^2/6;"
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :maxin "Sum(((x^i)*(factorial(i)^-1)),[i,0,Infinity]);"
  :maxout "%e^x;"
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :maxin "Sum((a*(r^i)),[i,0,n]);"
  :maxout "a*(r^(n+1)-1)/(r-1);"
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :maxin "Sum(f(i,j),[i,[a,b]],[j,1,2]);"
  :maxout "f(b,2)+f(b,1)+f(a,2)+f(a,1);"
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :maxin "Sum(f(i,j),[i,1,3],[j,1,i]);"
  :maxout "f(3,3)+f(3,2)+f(3,1)+f(2,2)+f(2,1)+f(1,1);"
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :maxin "Sum(f(i,j),[i,1,3,2],[j,1,3,1/2]);"
  :maxout "f(3,3)+f(3,5/2)+f(3,2)+f(3,3/2)+f(3,1)+f(1,3)+f(1,5/2)+f(1,2)+f(1,3/2)
+f(1,1);"
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :maxin "Sum(f(i,j),[i,1,3],[j,1,3]);"
  :maxout "f(3,3)+f(3,2)+f(3,1)+f(2,3)+f(2,2)+f(2,1)+f(1,3)+f(1,2)+f(1,1);"
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :maxin "Sum(f(i),[i,[a,b,c]]);"
  :maxout "f(c)+f(b)+f(a);"
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :maxin "Sum(f(i),[i,1,4,2]);"
  :maxout "f(3)+f(1);"
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :maxin "Sum(f(i),[i,1,4]);"
  :maxout "f(4)+f(3)+f(2)+f(1);"
 ))

(help-item-add-example "Sum"
  (list 
  :type "br"
  :comments "expected pi^4/120"
  :maxin "Sum((((j^2)*((i+1)^2))^-1),[i,1,inf],[j,1,i]);"
  :maxout "('sum(1/(i^2+2*i+1),i,1,inf))*'sum(1/j^2,j,1,i);"
 ))

(help-item-add-example "Sum"
  (list 
  :type "br"
  :comments "Not implemented Indefinite sums.
 This causes a lisp error."
  :maxin "Sum((i^3),i);"
  :maxout ""
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :maxin "Sum(i,[i,[1,2,3,4]]);"
  :maxout "10;"
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :maxin "Sum(((i^6)^-1),[i,1,inf]);"
  :maxout "%pi^6/945;"
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :comments "Mma factors the follwing by default"
  :maxin "Sum((i^2),[i,1,n]);"
  :maxout "(2*n^3+3*n^2+n)/6;"
 ))

(help-item-add-example "Sum"
  (list 
  :type "ok"
  :maxin "Sum((i^2),[i,10]);"
  :maxout "385;"
 ))

(help-item-init "Array")

(help-item-add-example "Array"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Array(g,[2,2],[0,0],qq);
qq(qq(g(0,0),g(0,1)),qq(g(1,0),g(1,1))) ;"
  :mma "Array[g,{2,2},{0,0},qq]"
 ))

(help-item-add-example "Array"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Array(f,[2,3],[0,4]);
[[f(0,4),f(0,5),f(0,6)],[f(1,4),f(1,5),f(1,6)]] ;"
  :mma "Array[f,{2,3},{0,4}]"
 ))

(help-item-add-example "Array"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Array(f,10,0);
[f(0),f(1),f(2),f(3),f(4),f(5),f(6),f(7),f(8),f(9)] ;"
  :mma "Array[f,10,0]"
 ))

(help-item-add-example "Array"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Array(lambda( [[lambda_args]],  ((10*lambda_args[1])+lambda_args[2]) ),[3,4]);
[[11,12,13,14],[21,22,23,24],[31,32,33,34]] ;"
  :mma "Array[10 #1 +#2 &,{3,4}]"
 ))

(help-item-add-example "Array"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Array(f,[3,2]);
[[f(1,1),f(1,2)],[f(2,1),f(2,2)],[f(3,1),f(3,2)]] ;"
  :mma "Array[f,{3,2}]"
 ))

(help-item-add-example "Array"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Array(lambda( [[lambda_args]],  (1+(lambda_args[1]^2)) ),10);
[2,5,10,17,26,37,50,65,82,101] ;"
  :mma "Array[1 + #^2 &,10]"
 ))

(help-item-add-example "Array"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Array(f,10);
[f(1),f(2),f(3),f(4),f(5),f(6),f(7),f(8),f(9),f(10)] ;"
  :mma "Array[f,10]"
 ))

(help-item-add-example "Array"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Array(lambda( [[lambda_args]], (lambda_args[1]^lambda_args[2]) ),[3,4]);
[[1,1,1,1],[2,4,8,16],[3,9,27,81]] ;"
  :mma "Array[#1^#2 &,{3,4}]"
 ))

(help-item-add-example "Array"
  (list 
  :type "br"
  :maxin "Array(lambda( [arg1], Array(lambda( [], x ),arg1) ),[6]);"
  :maxout ""
 ))

(help-item-add-example "Array"
  (list 
  :type "br"
  :maxin "(m:Array(lambda( [], Subscript(a,SLOTSEQUENCE(1)) ),[3,4]));"
  :maxout ""
 ))

(help-item-add-example "Array"
  (list 
  :type "br"
  :maxin "Boole(Array(MGREATERP,[5,5]));"
  :maxout ""
 ))

(help-item-add-example "Array"
  (list 
  :type "br"
  :maxin "Array(lambda( [], Signature([SLOTSEQUENCE(1)]) ),[3,3,3]);"
  :maxout ""
 ))

(help-item-add-example "Array"
  (list 
  :type "br"
  :maxin "Array(lambda( [], 0 ),[3,3]);"
  :maxout ""
 ))

(help-item-add-example "Array"
  (list 
  :type "ok"
  :maxin "Array(\"^\",[5,5]);"
  :maxout "[[1,1,1,1,1],[2,4,8,16,32],[3,9,27,81,243],[4,16,64,256,1024],
[5,25,125,625,3125]];"
 ))

(help-item-add-example "Array"
  (list 
  :type "ok"
  :maxin "Array(f,[2,3],4);"
  :maxout "[[f(4, 4), f(4, 5), f(4, 6)], [f(5, 4), f(5, 5), f(5, 6)]];"
 ))

(help-item-add-example "Array"
  (list 
  :type "ok"
  :maxin "Array(f,[2,3],[0,4]);"
  :maxout "[[f(0, 4), f(0, 5), f(0, 6)], [f(1, 4), f(1, 5), f(1, 6)]];"
 ))

(help-item-add-example "Array"
  (list 
  :type "ok"
  :maxin "Array(f,10,0);"
  :maxout "[f(0), f(1), f(2), f(3), f(4), f(5), f(6), f(7), f(8), f(9)];"
 ))

(help-item-add-example "Array"
  (list 
  :type "ok"
  :maxin "Array(lambda( [arg1,arg2], ((10*arg1)+arg2) ),[3,4]);"
  :maxout "[[11, 12, 13, 14], [21, 22, 23, 24], [31, 32, 33, 34]];"
 ))

(help-item-add-example "Array"
  (list 
  :type "ok"
  :maxin "Array(f,[3,2]);"
  :maxout "[[f(1, 1), f(1, 2)], [f(2, 1), f(2, 2)], [f(3, 1), f(3, 2)]];"
 ))

(help-item-add-example "Array"
  (list 
  :type "ok"
  :maxin "Array(lambda( [arg1], (1+(arg1^2)) ),10);"
  :maxout "[2, 5, 10, 17, 26, 37, 50, 65, 82, 101];"
 ))

(help-item-add-example "Array"
  (list 
  :type "ok"
  :maxin "Array(f,10);"
  :maxout "[f(1), f(2), f(3), f(4), f(5), f(6), f(7), f(8), f(9), f(10)];"
 ))

(help-item-init "Det")

(help-item-add-example "Det"
  (list 
  :type "ok"
  :maxin "Det(Array(a,[3,3]));"
  :maxout "a(1,1)*(a(2,2)*a(3,3)-a(2,3)*a(3,2))
-a(1,2)*(a(2,1)*a(3,3)-a(2,3)*a(3,1))
+a(1,3)*(a(2,1)*a(3,2)-a(2,2)*a(3,1));"
 ))

(help-item-add-example "Det"
  (list 
  :type "ok"
  :maxin "Det(Array(a,[2,2]));"
  :maxout "a(1,1)*a(2,2)-a(1,2)*a(2,1);"
 ))

(help-item-add-example "Det"
  (list 
  :type "ok"
  :maxin "Det(matrix([1,2,3],[4,5,6],[7,8,9]));"
  :maxout "0;"
 ))

(help-item-add-example "Det"
  (list 
  :type "ok"
  :maxin "Det([[1,2,3],[4,5,6],[7,8,9]]);"
  :maxout "0;"
 ))

(help-item-init "Dimensions")

(help-item-add-example "Dimensions"
  (list 
  :type "ok"
  :maxin "Dimensions([[0,1],1]);"
  :maxout "[2];"
 ))

(help-item-add-example "Dimensions"
  (list 
  :type "ok"
  :maxin "Dimensions([[],[a+b]]);"
  :maxout "[2];"
 ))

(help-item-add-example "Dimensions"
  (list 
  :type "ok"
  :maxin "Dimensions([[],[]]);"
  :maxout "[2, 0];"
 ))

(help-item-add-example "Dimensions"
  (list 
  :type "ok"
  :comments "Following are not Mma examples."
  :maxin "Dimensions(a);"
  :maxout "[];"
 ))

(help-item-add-example "Dimensions"
  (list 
  :type "ok"
  :maxin "Dimensions(Array(a,[2,1,4,3]));"
  :maxout "[2, 1, 4, 3];"
 ))

(help-item-add-example "Dimensions"
  (list 
  :type "ok"
  :maxin "Dimensions(f(g(x,y),g(a,b),g(s,t)));"
  :maxout "[3];"
 ))

(help-item-add-example "Dimensions"
  (list 
  :type "ok"
  :maxin "Dimensions(f(f(x,y),f(a,b),f(s,t)));"
  :maxout "[3, 2];"
 ))

(help-item-add-example "Dimensions"
  (list 
  :type "ok"
  :maxin "Dimensions([[[[a,b]]]],2);"
  :maxout "[1, 1];"
 ))

(help-item-add-example "Dimensions"
  (list 
  :type "ok"
  :maxin "Dimensions([[[[a,b]]]]);"
  :maxout "[1, 1, 1, 2];"
 ))

(help-item-add-example "Dimensions"
  (list 
  :type "ok"
  :maxin "Dimensions([[a,b,c],[d,e],[f]]);"
  :maxout "[3];"
 ))

(help-item-add-example "Dimensions"
  (list 
  :type "ok"
  :maxin "Dimensions([[a,b,c],[d,e,f]]);"
  :maxout "[2, 3];"
 ))

(help-item-init "Union")

(help-item-add-example "Union"
  (list 
  :type "ok"
  :comments "union works with other heads"
  :maxin "Union(g[a,b,c],g[c,d,e]);"
  :maxout "g(a,b,c,d,e);"
 ))

(help-item-add-example "Union"
  (list 
  :type "ok"
  :maxin "is(Union({}) = {});"
  :maxout "true;"
 ))

(help-item-add-example "Union"
  (list 
  :type "ok"
  :maxin "Union([]);"
  :maxout "[];"
 ))

(help-item-add-example "Union"
  (list 
  :type "ok"
  :maxin "Union({a,b,c},[c,d,e], {a,b,c,d,e,f,z});"
  :maxout "set(a,b,c,d,e,f,z);"
 ))

(help-item-add-example "Union"
  (list 
  :type "ok"
  :maxin "is (Union({a,b,c},[c,d,e], {a,b,c,d,e,f,z}) = {a,b,c,d,e,f,z});"
  :maxout "true;"
 ))

(help-item-add-example "Union"
  (list 
  :type "ok"
  :maxin "is(Union({a,b,c},[c,d,e]) = {a,b,c,d,e});"
  :maxout "true;"
 ))

(help-item-add-example "Union"
  (list 
  :type "ok"
  :maxin "Union([a,b,c],{c,d,e});"
  :maxout "[a,b,c,d,e];"
 ))

(help-item-add-example "Union"
  (list 
  :type "ok"
  :maxin "Union([a, b, a, c], [d, a, e, b], [c, a]);"
  :maxout "[a,b,c,d,e];"
 ))

(help-item-add-example "Union"
  (list 
  :type "ok"
  :maxin "Union([1, 2, 1, 3, 6, 2, 2]);"
  :maxout "[1,2,3,6];"
 ))

(help-item-init "Intersection")

(help-item-add-example "Intersection"
  (list 
  :type "ok"
  :maxin "is (Intersection({a,b,c},[c,d,e,b], {a,b,c,d,e,f,z}) = {b,c});"
  :maxout "true;"
 ))

(help-item-add-example "Intersection"
  (list 
  :type "ok"
  :maxin "is(Intersection({a,b,c},[c,d,e]) = {c});"
  :maxout "true;"
 ))

(help-item-add-example "Intersection"
  (list 
  :type "ok"
  :maxin "Intersection([a,b,c],{c,d,e});"
  :maxout "[c];"
 ))

(help-item-add-example "Intersection"
  (list 
  :type "ok"
  :maxin "is(Intersection({a,b,c}) =  {a,b,c});"
  :maxout "true;"
 ))

(help-item-add-example "Intersection"
  (list 
  :type "ok"
  :comments "head of type returned by Intersection is same as that of head of first arg"
  :maxin "Intersection([a,b,c]);"
  :maxout "[a,b,c];"
 ))

(help-item-init "Complement")

(help-item-add-example "Complement"
  (list 
  :type "br"
  :comments "returns [d]; expected f[d];"
  :maxin "Complement(f(a,b,c,d),f(c,a),f(b,b,a));"
  :maxout ""
 ))

(help-item-add-example "Complement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Complement([0,0,6]);
[0, 6] ;"
  :mma "Complement[{0,0,6}]"
 ))

(help-item-add-example "Complement"
  (list 
  :type "ok"
  :maxin "Complement([a,b,c,d,e],[a,c],[d]);"
  :maxout "[b,e];"
 ))

(help-item-init "TrigExpand")

(help-item-add-example "TrigExpand"
  (list 
  :type "ok"
  :maxin "TrigExpand(Cos((4*x)));"
  :maxout "sin(x)^4-6*cos(x)^2*sin(x)^2+cos(x)^4;"
 ))

(help-item-init "D")

(help-item-add-example "D"
  (list 
  :type "br"
  :comments "formal variables does not work"
  :maxin "D(f(x), f(x));"
  :maxout ""
 ))

(help-item-add-example "D"
  (list 
  :type "ok"
  :maxin "D(f(x,y),y,x);"
  :maxout "'diff(f(x,y),x,1,y,1);"
 ))

(help-item-add-example "D"
  (list 
  :type "ok"
  :comments "These work insofar as they return a correct Maxima expression"
  :maxin "D(f(x,y),x,y);"
  :maxout "'diff(f(x,y),x,1,y,1);"
 ))

(help-item-add-example "D"
  (list 
  :type "br"
  :comments "derivative tensors do not work"
  :maxin "D([Sin(y),(Sin(x)+Cos(y))],[[x,y],2]);"
  :maxout ""
 ))

(help-item-add-example "D"
  (list 
  :type "ok"
  :comments "gradient works"
  :maxin "D(((x^2)*Sin(y)),[[x,y]]);"
  :maxout "[2*x*sin(y),x^2*cos(y)];"
 ))

(help-item-add-example "D"
  (list 
  :type "ok"
  :comments "but this does work..."
  :maxin "D(x*f(x)*'diff(f(x),x),x);"
  :maxout "x*f(x)*'diff(f(x),x,2)+x*('diff(f(x),x,1))^2+f(x)*'diff(f(x),x,1);"
 ))

(help-item-add-example "D"
  (list 
  :type "br"
  :comments "using primes does not translate correctly"
  :maxin "D((x*f(x)*Derivative(1) f x),x);"
  :maxout "Incorrect syntax: F is not an infix operator;"
 ))

(help-item-add-example "D"
  (list 
  :type "ok"
  :maxin "D((Sin((x*y))*(((x^2)+(y^2))^-1)),x,y);"
  :maxout "-x*y*sin(x*y)/(y^2+x^2)+8*x*y*sin(x*y)/(y^2+x^2)^3+cos(x*y)/(y^2+x^2)
-2*y^2*cos(x*y)/(y^2+x^2)^2
-2*x^2*cos(x*y)/(y^2+x^2)^2;"
 ))

(help-item-add-example "D"
  (list 
  :type "ok"
  :maxin "D((Sin(x)^10),[x,4]);"
  :maxout "280*sin(x)^10-4680*cos(x)^2*sin(x)^8+5040*cos(x)^4*sin(x)^6;"
 ))

(help-item-add-example "D"
  (list 
  :type "ok"
  :maxin "D((x^n),x);"
  :maxout "n*x^(n-1);"
 ))

(help-item-init "Prepend")

(help-item-add-example "Prepend"
  (list 
  :type "ok"
  :maxin "block( [ ls : [a, b, c, d] ],
PrependTo(ls, x),
ls);"
  :maxout "[x,a,b,c,d];"
 ))

(help-item-add-example "Prepend"
  (list 
  :type "ok"
  :maxin "Prepend([a, b, c, d], x);"
  :maxout "[x,a,b,c,d];"
 ))

(help-item-init "Fold")

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :comments "fold with empty list"
  :maxin "Fold(f,x,[]);"
  :maxout "x;"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :maxin "Fold(lambda([s, e], Join(s, map(lambda([x],Append(x,e)),s))), [[]], [a, b, c]);"
  :maxout "[[],[a],[b],[a,b],[c],[a,c],[b,c],[a,b,c]];"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :maxin "Fold(lambda([s, e], Riffle(s, map(lambda([x],Append(x,e)),s))), [[]], [a, b, c]);"
  :maxout "[[],[c],[b],[b,c],[a],[a,c],[a,b],[a,b,c]];"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :maxin "Fold(lambda([s, e], join(s, map(lambda([x],Append(x,e)),s))), [[]], [a, b, c]);"
  :maxout "[[],[c],[b],[b,c],[a],[a,c],[a,b],[a,b,c]];"
 ))

(help-item-add-example "Fold"
  (list 
  :type "br"
  :comments "Find  all possible subsets of a list (ie find the power set).
 this only works on a list of   unique elements as written."
  :maxin ""
  :maxout ""
  :mma "Fold[Function[{s, e}, Join[s, Append[#, e] & /@ s]], {{}}, {a, b, c}]"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :comments "All possible sums formed from a list of numbers."
  :maxin "Fold(lambda([x,y], Union(x, x + y)), [0], [1, 2, 2, 8]);"
  :maxout "[0,1,2,3,4,5,8,9,10,11,12,13];"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :comments "functions that ignore second argument give same result as Nest"
  :maxin "Fold(lambda([x,y],f(x)) , x, Range(5));"
  :maxout "f(f(f(f(f(x)))));"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :comments "apply an indexed sequence of functions."
  :maxin "Fold( lambda([x,y], part([f(x,x),g(x)],y)),e,[1,1,2,1,2]);"
  :maxout "g(f(g(f(f(e,e),f(e,e))),g(f(f(e,e),f(e,e)))));"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :comments "function composition"
  :maxin "Fold(lambda([x,y],apply(y,[x])), x, [a,b,c,d]);"
  :maxout "d(c(b(a(x))));"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :comments "left branching binary tree."
  :maxin "Fold( lambda([x,y], [y,x]), x, [a, b, c, d]);"
  :maxout "[d,[c,[b,[a,x]]]];"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :comments "alternating sum. Maxima reorders terms."
  :maxin "Fold(lambda([x,y],y - x), 0, reverse([a, b, c, d, e]));"
  :maxout "e-d+c-b+a;"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :maxin "Fold(lambda([x,y], 10*x + y), 0, [4, 5, 1, 6, 7, 8]);"
  :maxout "451678;"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :maxin "Fold(lambda([x,y], 1/(y + x)), x, reverse([a, b, c, d]));"
  :maxout "1/(1/(1/(1/(x+d)+c)+b)+a);"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :maxin "Fold(lambda( [i,j] , x * i + j ), 0, [a, b, c, d, e]);"
  :maxout "x*(x*(x*(a*x+b)+c)+d)+e;"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :comments "Head of last argument need not be a list."
  :maxin "Fold(f,x, p[a,b,c,d]);"
  :maxout "f(f(f(f(x,a),b),c),d);"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :comments "Fold to the right"
  :maxin "Fold(lambda([x,y], g(y,x)), x, [a,b,c,d]);"
  :maxout "g(d,g(c,g(b,g(a,x))));"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :maxin "catch(Fold(lambda([x,y], if x > 1e6 then throw(x) else x^y),2, Range(6)));"
  :maxout "16777216;"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :maxin "Fold(lambda([x,y], x^y),x,[a,b,c,d]);"
  :maxout "(((x^a)^b)^c)^d;"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :maxin "Fold(\"*\",1,[a,b,c,d]);"
  :maxout "a*b*c*d;"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :comments "apply the list operator to create binary tree"
  :maxin "Fold( \"[\" ,x,[a,b,c,d]);"
  :maxout "[[[[x,a],b],c],d];"
 ))

(help-item-add-example "Fold"
  (list 
  :type "ok"
  :comments "This is what Fold does generically"
  :maxin "Fold(f,x,[a,b,c,d]);"
  :maxout "f(f(f(f(x,a),b),c),d);"
 ))

(help-item-init "ArrayDepth")

(help-item-add-example "ArrayDepth"
  (list 
  :type "ok"
  :maxin "ArrayDepth(Array(a,[4,5,2]));"
  :maxout "3;"
 ))

(help-item-add-example "ArrayDepth"
  (list 
  :type "ok"
  :maxin "Dimensions(Array(a,[4,5,2]));"
  :maxout "[4, 5, 2];"
 ))

(help-item-add-example "ArrayDepth"
  (list 
  :type "ok"
  :maxin "ArrayDepth(f(f(a,b),f(c,d)));"
  :maxout "2;"
 ))

(help-item-add-example "ArrayDepth"
  (list 
  :type "ok"
  :maxin "ArrayDepth([[a,b],[c]]);"
  :maxout "1;"
 ))

(help-item-add-example "ArrayDepth"
  (list 
  :type "ok"
  :maxin "ArrayDepth([[a,b],[c,d]]);"
  :maxout "2;"
 ))

(help-item-init "Flatten")

(help-item-add-example "Flatten"
  (list 
  :type "ok"
  :comments "Choosing heads with Flat is not supported. Also, I am not sure
 if mma Flatten continues to descend even after hitting a level with
 no lists to flatten. This maxima Flatten does not."
  :maxin "Flatten(f(f(x,y),z));"
  :maxout "f(x, y, z);"
 ))

(help-item-add-example "Flatten"
  (list 
  :type "ok"
  :maxin "Flatten([0,[1],[[2,-2]],[[[3],[-3]]],[[[[4]]]]]);"
  :maxout "[0, 1, 2, - 2, 3, - 3, 4];"
 ))

(help-item-add-example "Flatten"
  (list 
  :type "ok"
  :maxin "Flatten([0,[1],[[2,-2]],[[[3],[-3]]],[[[[4]]]]],inf);"
  :maxout "[0, 1, 2, - 2, 3, - 3, 4];"
 ))

(help-item-add-example "Flatten"
  (list 
  :type "ok"
  :maxin "Flatten([0,[1],[[2,-2]],[[[3],[-3]]],[[[[4]]]]],4);"
  :maxout "[0, 1, 2, - 2, 3, - 3, 4];"
 ))

(help-item-add-example "Flatten"
  (list 
  :type "ok"
  :maxin "Flatten([0,[1],[[2,-2]],[[[3],[-3]]],[[[[4]]]]],3);"
  :maxout "[0, 1, 2, - 2, 3, - 3, [4]];"
 ))

(help-item-add-example "Flatten"
  (list 
  :type "ok"
  :maxin "Flatten([0,[1],[[2,-2]],[[[3],[-3]]],[[[[4]]]]],2);"
  :maxout "[0, 1, 2, - 2, [3], [- 3], [[4]]];"
 ))

(help-item-add-example "Flatten"
  (list 
  :type "ok"
  :maxin "Flatten([0,[1],[[2,-2]],[[[3],[-3]]],[[[[4]]]]],1);"
  :maxout "[0, 1, [2, - 2], [[3], [- 3]], [[[4]]]];"
 ))

(help-item-add-example "Flatten"
  (list 
  :type "ok"
  :maxin "Flatten([0,[1],[[2,-2]],[[[3],[-3]]],[[[[4]]]]],0);"
  :maxout "[0, [1], [[2, - 2]], [[[3], [- 3]]], [[[[4]]]]];"
 ))

(help-item-add-example "Flatten"
  (list 
  :type "ok"
  :maxin "Flatten([[a,be],[c,[d],e],[f,[g,h]]],1);"
  :maxout "[a, be, c, [d], e, f, [g, h]];"
 ))

(help-item-add-example "Flatten"
  (list 
  :type "ok"
  :maxin "Flatten([[a,b],[c,[d],e],[f,[g,h]]]);"
  :maxout "[a, b, c, d, e, f, g, h];"
 ))

(help-item-init "PreDecrement")

(help-item-add-example "PreDecrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((x:1),(y:3),(z:4),PreDecrement([x,y,[z]]));
[0, 2, [3]] ;"
  :mma "x=1;y=3;z=4;PreDecrement[{x,y,{z}}]"
 ))

(help-item-add-example "PreDecrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((y:a),(PreDecrement(y)-y));
0 ;"
  :mma "y=a;PreDecrement[y]-y"
 ))

(help-item-add-example "PreDecrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((y:a),PreDecrement(y));
a-1 ;"
  :mma "y=a;PreDecrement[y]"
 ))

(help-item-add-example "PreDecrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "(PreDecrement(y)-y);
0 ;"
  :mma "PreDecrement[y]-y"
 ))

(help-item-add-example "PreDecrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((y:1),PreDecrement(y));
0 ;"
  :mma "y=1;PreDecrement[y]"
 ))

(help-item-add-example "PreDecrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "(kill(z), PreDecrement(z));
z-1$"
  :mma "PreDecrement[z]"
 ))

(help-item-init "Inverse")

(help-item-add-example "Inverse"
  (list 
  :type "ok"
  :maxin "Inverse( matrix( [a,b],[c,d]));"
  :maxout "matrix([d/(a*d-b*c),-b/(a*d-b*c)],[-c/(a*d-b*c),a/(a*d-b*c)]);"
 ))

(help-item-add-example "Inverse"
  (list 
  :type "ok"
  :maxin "Inverse( [ [a,b],[c,d]]);"
  :maxout "[[d/(a*d-b*c),-b/(a*d-b*c)],[-c/(a*d-b*c),a/(a*d-b*c)]];"
 ))

(help-item-init "If")

(help-item-add-example "If"
  (list 
  :type "br"
  :maxin ""
  :maxout "If(TrueQ((a<b)),1,0);
If(TrueQ(a < b),1,0) ;"
  :mma "If[TrueQ[a<b],1,0]"
 ))

(help-item-add-example "If"
  (list 
  :type "ok"
  :maxin ""
  :maxout "If((a<b),1,0,Indeterminate);
Indeterminate ;"
  :mma "If[a<b,1,0,Indeterminate]"
 ))

(help-item-add-example "If"
  (list 
  :type "ok"
  :maxin ""
  :maxout "If((a<b),1,0);
If(a < b,1,0) ;"
  :mma "If[a<b,1,0]"
 ))

(help-item-init "IntegerExponent")

(help-item-add-example "IntegerExponent"
  (list 
  :type "ok"
  :maxin "IntegerExponent(2^8,2);"
  :maxout "8;"
 ))

(help-item-init "Map")

(help-item-add-example "Map"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Map(f,[a,b,c]);
[f(a),f(b),f(c)] ;"
  :mma "Map[f,{a,b,c}]"
 ))

(help-item-init "Select")

(help-item-add-example "Select"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Select(Tuples([a,b],4),lambda( [[lambda_args]], (lambda_args[1]=Reverse(lambda_args[1])) ));
[[a, a, a, a], [a, b, b, a], [b, a, a, b], [b, b, b, b]];"
  :mma "Select[Tuples[{a, b}, 4], # == Reverse[#] &]"
 ))

(help-item-add-example "Select"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Select(Range(100),lambda( [[lambda_args]], ((Mod(lambda_args[1],3)=1) and (Mod(lambda_args[1],5)=1)) ));
[1, 16, 31, 46, 61, 76, 91];"
  :mma "Select[Range[100], Mod[#, 3] == 1 && Mod[#, 5] == 1 &]"
 ))

(help-item-add-example "Select"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Select(f(1,a,2,b,3),IntegerQ);
f(1, 2, 3);"
  :mma "Select[f[1, a, 2, b, 3], IntegerQ]"
 ))

(help-item-add-example "Select"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Select([1,2,4,7,x],lambda( [[lambda_args]], (lambda_args[1]>2) ));
[4, 7];"
  :mma "Select[{1, 2, 4, 7, x}, # > 2 &]"
 ))

(help-item-add-example "Select"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Select([1,2,4,7,6,2],lambda( [[lambda_args]], (lambda_args[1]>2) ),1);
[4];"
  :mma "Select[{1, 2, 4, 7, 6, 2}, # > 2 &, 1]"
 ))

(help-item-add-example "Select"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Select([1,2,4,7,6,2],lambda( [[lambda_args]], (lambda_args[1]>2) ));
[4, 7, 6];"
  :mma "Select[{1, 2, 4, 7, 6, 2}, # > 2 &]"
 ))

(help-item-add-example "Select"
  (list 
  :type "ok"
  :maxin "Select([1,2,4,7,6,2],EvenQ);"
  :maxout "[2, 4, 6, 2];"
  :mma "Select[{1, 2, 4, 7, 6, 2}, EvenQ]"
 ))

(help-item-init "NIntegrate")

(help-item-add-example "NIntegrate"
  (list 
  :type "ok"
  :maxin "Chop( NIntegrate(sin(sin(x)),[x,0,2], Rule(Method,NewtonCotesRule),Rule(MinRecursion,2),Rule(MaxRecursion,12),Rule(PrecisionGoal,10),Rule(AccuracyGoal,Infinity)) - 1.247056058244003, 1e-7);"
  :maxout "0;"
 ))

(help-item-add-example "NIntegrate"
  (list 
  :type "ok"
  :comments "Mma detects this automatically"
  :maxin "Chop(NIntegrate((Sin((2000*x))*(Sqrt(x)^-1)),[x,0,2],Rule(Method,Oscillatory))-0.0282830615003, 1e-7);"
  :maxout "0;"
 ))

(help-item-add-example "NIntegrate"
  (list 
  :type "ok"
  :maxin "Chop(NIntegrate(((Log(x)*(Sqrt(x)^-1))+(Sqrt((1-x))^-1)),[x,0,1]) + 2,1e-7);"
  :maxout "0;"
 ))

(help-item-add-example "NIntegrate"
  (list 
  :type "ok"
  :comments "quadrature is detected in these cases"
  :maxin "NIntegrate(Exp((-1*x)),[x,0,Infinity]);"
  :maxout "1.0;"
 ))

(help-item-add-example "NIntegrate"
  (list 
  :type "ok"
  :maxin "NIntegrate(x*y*z,[x,0,2],[y,0,2],[z,0,2]);"
  :maxout "8.0;"
 ))

(help-item-add-example "NIntegrate"
  (list 
  :type "ok"
  :comments "Can't detect automatically"
  :maxin "Chop(NIntegrate(Sin(9*x^3)*Sqrt(x),[x,1,10],Rule(Method,Oscillatory)) + 0.031722571737888,1e-7);"
  :maxout "0;"
 ))

(help-item-add-example "NIntegrate"
  (list 
  :type "ok"
  :comments "Can't detect this singularity"
  :maxin "Chop(NIntegrate(Sin(x)/x,[x,0,1],Rule(Method,QagsRule)) - 0.94608307036718, 1e-7);"
  :maxout "0;"
 ))

(help-item-add-example "NIntegrate"
  (list 
  :type "ok"
  :maxin "Chop(NIntegrate(1/Sqrt(x-1),[x,1,2])-2,1e-7);"
  :maxout "0;"
 ))

(help-item-add-example "NIntegrate"
  (list 
  :type "ok"
  :comments "detect singularities"
  :maxin "Chop(NIntegrate(1/Sqrt(x),[x,0,1])-2,1e-7);"
  :maxout "0;"
 ))

(help-item-add-example "NIntegrate"
  (list 
  :type "ok"
  :maxin "NIntegrate(((x^2)+(y^2)),[x,-1,1],[y,-1,1]);"
  :maxout "2.666666666666667;"
 ))

(help-item-add-example "NIntegrate"
  (list 
  :type "ok"
  :maxin "NIntegrate(Exp((-1*(x^2))),[x,(-1*Infinity),Infinity]);"
  :maxout "1.772453850905516;"
 ))

(help-item-add-example "NIntegrate"
  (list 
  :type "ok"
  :maxin "Chop(NIntegrate(Sin(Sin(x)),[x,0,2]) - 1.2470560582440,1e-7);"
  :maxout "0;"
 ))

(help-item-add-example "NIntegrate"
  (list 
  :type "ok"
  :maxin "Chop(NIntegrate(Sin(x*y),[x,0,1],[y,0,x]) - 0.11990590880424,1e-7);"
  :maxout "0;"
 ))

(help-item-add-example "NIntegrate"
  (list 
  :type "ok"
  :maxin "NIntegrate(x*y,[x,0,1],[y,0,1]);"
  :maxout "0.25;"
 ))

(help-item-init "Increment")

(help-item-add-example "Increment"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((x:1),(y:3),(z:4),Increment([x,y,[z]]));
[1, 3, [4]] ;"
  :mma "x=1;y=3;z=4;Increment[{x,y,{z}}]"
 ))

(help-item-add-example "Increment"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((y:a),(Increment(y)-y));
- 1 ;"
  :mma "y=a;Increment[y]-y"
 ))

(help-item-add-example "Increment"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((y:a),Increment(y));
a ;"
  :mma "y=a;Increment[y]"
 ))

(help-item-add-example "Increment"
  (list 
  :type "ok"
  :maxin ""
  :maxout "(Increment(y)-y);
- 1 ;"
  :mma "Increment[y]-y"
 ))

(help-item-add-example "Increment"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((y:1),Increment(y));
1 ;"
  :mma "y=1;Increment[y]"
 ))

(help-item-add-example "Increment"
  (list 
  :type "ok"
  :comments "Mma prints error and returns Increment(z)
 we disabled that check and allow everything."
  :maxin ""
  :maxout "(kill(z), Increment(z));
z$"
  :mma "Increment[z]"
 ))

(help-item-add-example "Increment"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((cat:\"dog\"),(Increment(cat)-cat));
- 1 ;"
  :mma "cat=dog;Increment[cat]-cat"
 ))

(help-item-init "NestList")

(help-item-add-example "NestList"
  (list 
  :type "ok"
  :comments "first 10 primes"
  :maxin "NestList(next_prime,1,10);"
  :maxout "[2,3,5,7,11,13,17,19,23,29];"
 ))

(help-item-init "Head")

(help-item-add-example "Head"
  (list 
  :type "ok"
  :maxin "Head(\"hi\");"
  :maxout "String;"
 ))

(help-item-add-example "Head"
  (list 
  :type "ok"
  :maxin "Head(3.0+4.1*%i);"
  :maxout "Complex;"
 ))

(help-item-add-example "Head"
  (list 
  :type "ok"
  :maxin "Head(3+4*%i);"
  :maxout "Complex;"
 ))

(help-item-add-example "Head"
  (list 
  :type "ok"
  :maxin "Head(%i);"
  :maxout "Complex;"
 ))

(help-item-add-example "Head"
  (list 
  :type "ok"
  :comments "Mma does not appear to distinguish bigfloats in this way"
  :maxin "Head(N(%pi,100));"
  :maxout "Real;"
 ))

(help-item-add-example "Head"
  (list 
  :type "ok"
  :maxin "Head(3.0);"
  :maxout "Real;"
 ))

(help-item-add-example "Head"
  (list 
  :type "ok"
  :maxin "Head(3/4);"
  :maxout "Rational;"
 ))

(help-item-add-example "Head"
  (list 
  :type "ok"
  :comments "Mma gives Times here"
  :maxin "Head(a/b);"
  :maxout "\"/\";"
 ))

(help-item-add-example "Head"
  (list 
  :type "ok"
  :maxin "Head(f[x][y][z]);"
  :maxout "f[x][y];"
 ))

(help-item-add-example "Head"
  (list 
  :type "ok"
  :maxin "Head(x);"
  :maxout "Symbol;"
 ))

(help-item-add-example "Head"
  (list 
  :type "ok"
  :maxin "Head(45);"
  :maxout "Integer;"
 ))

(help-item-add-example "Head"
  (list 
  :type "ok"
  :maxin "Head([a,b,c]);"
  :maxout "\"[\";"
 ))

(help-item-add-example "Head"
  (list 
  :type "ok"
  :maxin "Head(a+b+c);"
  :maxout "\"+\";"
 ))

(help-item-add-example "Head"
  (list 
  :type "ok"
  :maxin "Head(f(a,b));"
  :maxout "f;"
 ))

(help-item-init "Chop")

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :maxin "Chop(exp(float(Range(4) * %i*%pi)));"
  :maxout "[-1.0,1.0,-1.0,1.0];"
 ))

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :maxin "Chop(1e-6 + 3 * %i, 1e-5);"
  :maxout "3*%i;"
 ))

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :maxin "Chop(Chop(1e-6 + 3 * %i) - (3*%i + 1e-6));"
  :maxout "0;"
 ))

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :maxin "Chop(1e-20 + 3 * %i);"
  :maxout "3*%i;"
 ))

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :maxin "Chop(1+ 1e-20 * %i);"
  :maxout "1;"
 ))

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :maxin "Chop(1+%i);"
  :maxout "%i+1;"
 ))

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :maxin "Chop([1e-6,1e-17,1e-8],1e-3);"
  :maxout "[0,0,0];"
 ))

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :maxin "Chop([1e-6,1e-17,1e-8]);"
  :maxout "[9.9999999999999995E-7,0,1.0E-8];"
 ))

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :comments "at mulitple levels"
  :maxin "Chop([1,1e-20, [1.4, 1e-19] ]);"
  :maxout "[1,0,[1.4,0]];"
 ))

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :comments "maps over a list"
  :maxin "Chop([1,1e-20]);"
  :maxout "[1,0];"
 ))

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :maxin "Chop(-1e-17);"
  :maxout "0;"
 ))

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :maxin "Chop(-1);"
  :maxout "-1;"
 ))

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :comments "number smaller than chopEpsilon : 1e-10 in abs val  is set to zero"
  :maxin "Chop(1e-17);"
  :maxout "0;"
 ))

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :maxin "Chop( 1 + 1e-20* %i - 7*(a + 1e-30* b)*%i);"
  :maxout "1-7*%i*a;"
 ))

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :comments "symbol remains unsimplified"
  :maxin "Chop(a);"
  :maxout "a;"
 ))

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :comments "numbers that are not close to zero fall through."
  :maxin "Chop(1);"
  :maxout "1;"
 ))

(help-item-add-example "Chop"
  (list 
  :type "ok"
  :maxin "Chop(exp(N(Range(4)* %pi  * %i)));"
  :maxout "[-1.0,1.0,-1.0,1.0];"
 ))

(help-item-init "TrigReduce")

(help-item-add-example "TrigReduce"
  (list 
  :type "ok"
  :maxin "TrigReduce(TrigExpand(Cos((4*x))));"
  :maxout "cos(4*x);"
 ))

(help-item-init "Table")

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin "map(lambda([x],Last(IntegerDigits(x, 2))), [1,6,1,0,0,7,9,8]);"
  :maxout ""
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin "Table(Last(IntegerDigits(x, 2)), [x, [1,6,1,0,0,7,9,8]]);"
  :maxout "[1,0,1,0,0,1,1,0];"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "(Array(lambda( [[lambda_args]], (lambda_args[1]+Times(lambda_args[2],lambda_args[3])) ),[2,3,2])-Table((i1+Times(i2,i3)),[i1,2],[i2,3],[i3,2]));
[[[0, 0], [0, 0], [0, 0]], [[0, 0], [0, 0], [0, 0]]] ;"
  :mma "Array[(#1 +#2 #3)&,{2,3,2}]-Table[i1+i2 i3,{i1,2},{i2,3},{i3,2}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table(Sum((i^k),[k,4]),[i,8]);
[4, 30, 120, 340, 780, 1554, 2800, 4680] ;"
  :mma "Table[Sum[i^k,{k,4}],{i,8}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table(Times(i,(j^2),(k^3)),[i,2],[j,2],[k,2]);
[[[1, 8], [4, 32]], [[2, 16], [8, 64]]] ;"
  :mma "Table[ij^2 k^3,{i,2},{j,2},{k,2}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table((i+Times(2,j)),[i,3],[j,i]);
[[3], [4, 6], [5, 7, 9]] ;"
  :mma "Table[i+2 j,{i,3},{j,i}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table(((x^i)+(y^j)),[i,3],[j,2]);
[[y+x,y^2+x],[y+x^2,y^2+x^2],[y+x^3,y^2+x^3]] ;"
  :mma "Table[x^i+y^j,{i,3},{j,2}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "br"
  :comments "This is broken because it does return the list given. In mma, it fails because p is not evaluated."
  :maxin "block([(p:[x,5])],Table((x^2),p));"
  :maxout "[1,4,9,16,25] ;"
  :mma "Block[{p={x,5}},Table[x^2,p]]]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table(x,[x,0,10,3]);
[0,3,6,9] ;"
  :mma "Table[x,{x,0,10,3}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :comments "Using With instead of Module currently does not work.
 Mma prints error message here saying s is not of the correct form of an iterator."
  :maxin ""
  :maxout "block([(s:[i,5])],Table((i^2),s));
false$"
  :mma "Module[{s={i,5}},Table[i^2,s]]"
 ))

(help-item-add-example "Table"
  (list 
  :type "br"
  :comments "I believe that ## is not working under any circumstances."
  :maxin "Apply[Table[x, ##] &, %];"
  :maxout ""
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :comments "This works now because of => assignment operator."
  :maxin ""
  :maxout "Table([i(j),(j+1)],[j,3]);
[[i(1),2],[i(2),3],[i(3),4]] ;"
  :mma "Table[{i[j],j+1},{j,3}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "br"
  :comments "This works if Table evaluates iter, but not otherwise.
 In Mma, this example does work. Looks like Apply or the lambda form is evaluating the iterators.
 before passing them to Table"
  :maxin ""
  :maxout "Apply(lambda( [[lambda_args]], Table((i-j),lambda_args[1],lambda_args[2]) ),[[i,4],[j,5]]);
[[0, - 1, - 2, - 3, - 4], [1, 0, - 1, - 2, - 3], [2, 1, 0, - 1, - 2], [3, 2, 1, 0, - 1]] ;"
  :mma "Apply[Table[(i-j),#1,#2]&,{{i,4},{j,5}}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin "apply( lambda([x,y], Table(i - j, [i, x], [j, y])), [4,5]);"
  :maxout "[[0,-1,-2,-3,-4],[1,0,-1,-2,-3],[2,1,0,-1,-2],[3,2,1,0,-1]];"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table((x^y),[x,3],[y,4]);
[[1,1,1,1],[2,4,8,16],[3,9,27,81]] ;"
  :mma "Table[x^y,{x,3},{y,4}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table((Print(i),(i^(i^i))),[i,3]);
[1,16,7625597484987] ;"
  :mma "Table[Print[i];i^i^i,{i,3}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table(((x(1)^2)+(x(2)^2)),[x(1),3],[x(2),3]);
[[2,5,10],[5,8,13],[10,13,18]] ;"
  :mma "Table[x[1]^2 +x[2]^2,{x[1],3},{x[2],3}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table(factorial(a(x)),[a(x),6]);
[1,2,6,24,120,720] ;"
  :mma "Table[a[x]!,{a[x],6}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table(((2^x)+x),[x,a,(a+Times(5,n)),n]);
[2^a+a,2^(n+a)+n+a,2^(2*n+a)+2*n+a,2^(3*n+a)+3*n+a,2^(4*n+a)+4*n+a,
2^(5*n+a)+5*n+a] ;"
  :mma "Table[2^x+x,{x,a,a+5 n,n}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table((j^(i^-1)),[i,[1,2,4]],[j,[1,4,9]]);
[[1, 4, 9], [1, 2, 3], [1, sqrt(2), sqrt(3)]] ;"
  :mma "Table[j^(1/i),{i,{1,2,4}},{j,{1,4,9}}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table(Sqrt(x),[x,[1,4,9,16]]);
[1, 2, 3, 4] ;"
  :mma "Table[Sqrt[x],{x,{1,4,9,16}}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table((Times(100,i)+Times(10,j)+k),[i,3],[j,2],[k,4]);
[[[111, 112, 113, 114], [121, 122, 123, 124]],
[[211, 212, 213, 214], [221, 222, 223, 224]],
[[311, 312, 313, 314], [321, 322, 323, 324]]] ;"
  :mma "Table[100 i+10 j+k,{i,3},{j,2},{k,4}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table((Times(10,i)+j),[i,5],[j,i]);
[[11], [21, 22], [31, 32, 33], [41, 42, 43, 44], [51, 52, 53, 54, 55]] ;"
  :mma "Table[10 i+j,{i,5},{j,i}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table(f(i),[i,10,-5,-2]);
[f(10), f(8), f(6), f(4), f(2), f(0), f(- 2), f(- 4)] ;"
  :mma "Table[f[i],{i,10,-5,-2}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table((Times(10,i)+j),[i,4],[j,3]);
[[11, 12, 13], [21, 22, 23], [31, 32, 33], [41, 42, 43]] ;"
  :mma "Table[10 i+j,{i,4},{j,3}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table(x,[10]);
[x, x, x, x, x, x, x, x, x, x] ;"
  :mma "Table[x,{10}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table(f(i),[i,0,20,2]);
[f(0), f(2), f(4), f(6), f(8), f(10), f(12), f(14), f(16), f(18), f(20)] ;"
  :mma "Table[f[i],{i,0,20,2}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table((i^2),[i,10]);
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] ;"
  :mma "Table[i^2,{i,10}]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :comments "test that variable in surrounding scope does not interfere with iteration var.
 not an mma example."
  :maxin ""
  :maxout "block([i],(i:1),Table(i,[i,1,3]));
[1, 2, 3] ;"
  :mma "Module[{i},i=1,Table[i,{i,1,3}]]]"
 ))

(help-item-add-example "Table"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table(1);
1 ;"
  :mma "Table[1]"
 ))

(help-item-init "Tr")

(help-item-add-example "Tr"
  (list 
  :type "ok"
  :maxin "Tr(matrix([1,2,3],[4,5,6],[7,8,9]));"
  :maxout "15;"
 ))

(help-item-add-example "Tr"
  (list 
  :type "ok"
  :maxin "Tr([ [1,2,3],[4,5,6],[7,8,9] ]);"
  :maxout "15;"
 ))

(help-item-init "Gamma")

(help-item-add-example "Gamma"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Gamma(15/2);
135135*sqrt(%pi)/128 ;"
  :mma "Gamma[15/2]"
 ))

(help-item-init "StringJoin")

(help-item-add-example "StringJoin"
  (list 
  :type "ok"
  :maxin "StringJoin([[\"AB\", \"CD\"], \"XY\"]);"
  :maxout "\"ABCDXY\";"
 ))

(help-item-init "Partition")

(help-item-add-example "Partition"
  (list 
  :type "ni"
  :comments "padding and cycling to the beginning and other things are not done."
  :maxin "Partition([[11, 12, 13], [21, 22, 23], [31, 32, 33]], [2, 2], 1);"
  :maxout ""
 ))

(help-item-add-example "Partition"
  (list 
  :type "ok"
  :comments "partition into groups of two with an offset of 1.   ie, last element of first returned list is the same
 as the first element of the next list."
  :maxin "Partition([a, b, c, d, e, f], 3, 1);"
  :maxout "[[a,b,c],[b,c,d],[c,d,e],[d,e,f]];"
 ))

(help-item-add-example "Partition"
  (list 
  :type "ok"
  :comments "partition a list into groups of two ."
  :maxin "Partition([a, b, c, d, e, f], 2);"
  :maxout "[[a,b],[c,d],[e,f]];"
 ))

(help-item-init "Cos")

(help-item-add-example "Cos"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Cos((%pi*1/5));
(sqrt(5)+1)/4 ;"
  :mma "Cos[Pi/5]"
 ))

(help-item-init "For")

(help-item-add-example "For"
  (list 
  :type "ok"
  :comments "exit loop early with Return"
  :maxin "For( (c:0,i:1), i<= 10, i : i+1, (c:c+i,if i = 9 then Return(c)) );"
  :maxout "45$"
 ))

(help-item-add-example "For"
  (list 
  :type "ok"
  :maxin "( kill(i,c), c:0,  For( i:1, i<= 10, i : i+1,(c:c-i, if i>5 then Break(), c:c+i)), c);"
  :maxout "-6$"
 ))

(help-item-add-example "For"
  (list 
  :type "ok"
  :maxin "( kill(i,c), c:0,  For( i:1, i<= 10, i : i+1,(c:c-i, if i<5 then Continue(), c:c+i)), c);"
  :maxout "-10$"
 ))

(help-item-add-example "For"
  (list 
  :type "ok"
  :comments "only three args; no body"
  :maxin "( kill(i,c), c:0, For( i:1, i<= 10, (i : i+1, c:c+i) ) , c);"
  :maxout "65$"
 ))

(help-item-init "IntegerDigits")

(help-item-add-example "IntegerDigits"
  (list 
  :type "ok"
  :comments "First digits of factorials.    Changed somewhat from Mma example:
 Table(first(IntegerDigits(n!)), [n, 50]), which does not work here."
  :maxin "map(first,(Table(IntegerDigits(n!), [n, 50])));"
  :maxout "[1,2,6,2,1,7,5,4,3,3,3,4,6,8,1,2,3,6,1,2,5,1,2,6,1,4,1,3,8,2,8,2,8,2,1,
3,1,5,2,8,3,1,6,2,1,5,2,1,6,3];"
 ))

(help-item-add-example "IntegerDigits"
  (list 
  :type "br"
  :comments "fails to truncate"
  :maxin "IntegerDigits(6345354, 10, 4);"
  :maxout ""
 ))

(help-item-add-example "IntegerDigits"
  (list 
  :type "ok"
  :comments "with padding"
  :maxin "IntegerDigits(Range(0,7),2,3);"
  :maxout "[[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]];"
 ))

(help-item-add-example "IntegerDigits"
  (list 
  :type "ok"
  :maxin "IntegerDigits(Range(0,7),2);"
  :maxout "[[0],[1],[1,0],[1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]];"
 ))

(help-item-add-example "IntegerDigits"
  (list 
  :type "ok"
  :comments "thread over bases"
  :maxin "IntegerDigits(7,[2,3,4]);"
  :maxout "[[1,1,1],[2,1],[1,3]];"
 ))

(help-item-add-example "IntegerDigits"
  (list 
  :type "ok"
  :comments "thread over integers"
  :maxin "IntegerDigits([6,7,2],2);"
  :maxout "[[1,1,0],[1,1,1],[1,0]];"
 ))

(help-item-add-example "IntegerDigits"
  (list 
  :type "ok"
  :comments "Mma uses decimal digits as here. not letters"
  :maxin "IntegerDigits(58127,16);"
  :maxout "[14,3,0,15];"
 ))

(help-item-add-example "IntegerDigits"
  (list 
  :type "ok"
  :comments "base 2"
  :maxin "IntegerDigits(58127,2);"
  :maxout "[1,1,1,0,0,0,1,1,0,0,0,0,1,1,1,1];"
 ))

(help-item-add-example "IntegerDigits"
  (list 
  :type "ok"
  :maxin "IntegerDigits(58127);"
  :maxout "[5,8,1,2,7];"
 ))

(help-item-init "AppendTo")

(help-item-add-example "AppendTo"
  (list 
  :type "ok"
  :maxin "block( [ e : f[a, b, c]],
AppendTo(e, x+y),
e);"
  :maxout "f[a,b,c,y+x];"
 ))

(help-item-add-example "AppendTo"
  (list 
  :type "ok"
  :maxin "block( [ ls : [a, b, c, d] ],
AppendTo(ls, x),
ls);"
  :maxout "[a,b,c,d,x];"
 ))

(help-item-init "DivideBy")

(help-item-add-example "DivideBy"
  (list 
  :type "ok"
  :maxin ""
  :maxout "DivideBy(a,r);
(r*z-r)/r ;"
  :mma "DivideBy[a,r]"
 ))

(help-item-init "Coefficient")

(help-item-add-example "Coefficient"
  (list 
  :type "ni"
  :maxin "Coefficient(((x+1)^3),x,2,Rule(Modulus,2));"
  :maxout "1;"
 ))

(help-item-add-example "Coefficient"
  (list 
  :type "ok"
  :maxin "Coefficient(((x+y)*(x+(2*y))*((3*x)+(4*y)+5)),(x*(y^2)));"
  :maxout "18;"
 ))

(help-item-add-example "Coefficient"
  (list 
  :type "ok"
  :maxin "Coefficient((((x+2)^2)+((x+3)^3)),x,0);"
  :maxout "31;"
 ))

(help-item-add-example "Coefficient"
  (list 
  :type "ok"
  :maxin "Coefficient(((a*(x^3))+(b*(x^2))+(c*x)+d),x,2);"
  :maxout "b;"
 ))

(help-item-add-example "Coefficient"
  (list 
  :type "ok"
  :maxin "Coefficient(((a*x)+(b*y)+c),x);"
  :maxout "a;"
 ))

(help-item-add-example "Coefficient"
  (list 
  :type "ok"
  :maxin "Coefficient(((x+y)^4),(x*(y^3)));"
  :maxout "4;"
 ))

(help-item-add-example "Coefficient"
  (list 
  :type "ok"
  :maxin "Coefficient(((x+1)^3),x,2);"
  :maxout "3;"
 ))

(help-item-init "N")

(help-item-add-example "N"
  (list 
  :type "ok"
  :maxin "N(171!,10);"
  :maxout "1.241018070217668b309;"
 ))

(help-item-add-example "N"
  (list 
  :type "ok"
  :maxin "N(170!,20);"
  :maxout "7.2574156153079989674b306;"
 ))

(help-item-add-example "N"
  (list 
  :type "ok"
  :maxin "N(170!,10);"
  :maxout "7.257415615307999E+306;"
 ))

(help-item-add-example "N"
  (list 
  :type "ok"
  :maxin "N(171!,10);"
  :maxout "1.241018070217668b309;"
 ))

(help-item-add-example "N"
  (list 
  :type "ok"
  :maxin "N(171!);"
  :maxout "1.241018070217668b309;"
 ))

(help-item-add-example "N"
  (list 
  :type "ok"
  :maxin "N(170!);"
  :maxout "7.257415615307999E+306;"
 ))

(help-item-add-example "N"
  (list 
  :type "ok"
  :maxin "N(gamma(33/100), 50);"
  :maxout "2.7072062226151910490205221324559359517758917633167b0;"
 ))

(help-item-add-example "N"
  (list 
  :type "ok"
  :maxin "N(gamma(3.3), 50);"
  :maxout "2.683437381955768;"
 ))

(help-item-add-example "N"
  (list 
  :type "ok"
  :maxin "bfloatp(N(1/7,50));"
  :maxout "true;"
 ))

(help-item-add-example "N"
  (list 
  :type "ok"
  :maxin "N(1/7,50);"
  :maxout "1.4285714285714285714285714285714285714285714285714b-1;"
 ))

(help-item-add-example "N"
  (list 
  :type "ok"
  :maxin "floatnump(N(1/7));"
  :maxout "true;"
 ))

(help-item-add-example "N"
  (list 
  :type "ok"
  :comments "We must include more digits here than are actually printed
 when typing N(1/7) at the command line. All the precision in
 an ordinary float must be included int the comparison."
  :maxin "N(1/7);"
  :maxout "0.14285714285714285714;"
 ))

(help-item-init "TimesBy")

(help-item-add-example "TimesBy"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((a:z),TimesBy(a,r));
r*z ;"
  :mma "a=z;TimesBy[a,r]"
 ))

(help-item-init "IdentityMatrix")

(help-item-add-example "IdentityMatrix"
  (list 
  :type "ok"
  :maxin ""
  :maxout "KroneckerProduct(IdentityMatrix(3),[[1,2],[3,4]]);
[[1,2,0,0,0,0],[3,4,0,0,0,0],[0,0,1,2,0,0],[0,0,3,4,0,0],[0,0,0,0,1,2],
[0,0,0,0,3,4]] ;"
  :mma "KroneckerProduct[IdentityMatrix[3],{{1,2},{3,4}}]"
 ))

(help-item-add-example "IdentityMatrix"
  (list 
  :type "br"
  :maxin ""
  :maxout ""
  :mma "IdentityMatrix[3, WorkingPrecision -> MachinePrecision]"
 ))

(help-item-add-example "IdentityMatrix"
  (list 
  :type "ok"
  :comments "Not a square matrix"
  :maxin ""
  :maxout "IdentityMatrix(3);
[[1, 0, 0], [0, 1, 0], [0, 0, 1]] ;"
  :mma "IdentityMatrix[3]"
 ))

(help-item-add-example "IdentityMatrix"
  (list 
  :type "ok"
  :comments "Make a 3x3 identity matrix."
  :maxin ""
  :maxout "IdentityMatrix(3);
[[1, 0, 0], [0, 1, 0], [0, 0, 1]] ;"
  :mma "IdentityMatrix[3]"
 ))

(help-item-init "Function")

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "fromdigits(Reverse(Range(10)));
10987654321$"
  :mma "fromdigits[Reverse[Range[10]]]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "(fromdigits(digits):=Fold(Function(((10*Slot(1))+Slot(2))),0,digits),0);
0$"
  :mma "fromdigits[digits_] := Fold[(10 #1 + #2) &, 0, digits]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :comments "In Mma, the Evaluate is not necessary."
  :maxin ""
  :maxout "Evaluate(Apply(Function(Table(c,SlotSequence(1))),Map(List,[2,2])));
[[c, c], [c, c]]$"
  :mma "Evaluate[ Apply[Table[c, ##]&, Map[List, {2,2}]] ]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin "Function(u, 3 + u)(x);"
  :maxout "x+3$"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin "Function([u], 3 + u)(x);"
  :maxout "x+3$"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :comments "named arguments"
  :maxin "Function([u, v], u^2 + v^4)(x, y);"
  :maxout "y^4+x^2$"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Map(Function((Part(Slot(1),1)+(%i*Part(Slot(1),2)))),pairs);
[%i,%i+1,3*%i+2] ;"
  :mma "Map[#[[[1]]]+I#[[[2]]]&,pairs]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "(pairs=>Map(Function([Re(Slot(1)),Im(Slot(1))]),[%i,(1+%i),(2+(3*%i))]));
[[0,1],[1,1],[2,3]] ;"
  :mma "pairs=Map[{Re[#],Im[#]}&,{I,1 +I,2 +3 I}]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Apply(Function(f(SlotSequence(1),SlotSequence(1))),[x,y]);
f(x,y,x,y) ;"
  :mma "Apply[f[##,##]&,{x,y}]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Map(Function(Take(Slot(1),2)),[[2,1,7],[4,1,5],[3,1,2]]);
[[2,1],[4,1],[3,1]] ;"
  :mma "Map[Take[#,2]&,{{2,1,7},{4,1,5},{3,1,2}}]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Map(Function((f(Slot(1))+g(Slot(1)))),[a,b,c]);
[g(a)+f(a),g(b)+f(b),g(c)+f(c)] ;"
  :mma "Map[f[#] + g[#] &, {a,b,c} ]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "f3(a);
3*a ;"
  :mma "f3[a]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "(f3=>Function((Slot(1)+Slot(1)+Slot(1))));
lambda([[mixima_lambda_args]],
mix_nth(1,mixima_lambda_args)+mix_nth(1,mixima_lambda_args)
+mix_nth(1,mixima_lambda_args)) ;"
  :mma "f3=(#+#+#)&"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "fpq(x);
x+q ;"
  :mma "fpq[x]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "(fpq=>ReplaceAll(Function((p+Slot(1))),Rule(p,q)));
lambda([[mixima_lambda_args]],q+mix_nth(1,mixima_lambda_args)) ;"
  :mma "fpq = (((p + #) & )  /. p -> q)"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Map(Function(17),[1,2,3]);
[17,17,17] ;"
  :mma "(17 &) /@ {1,2,3}"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "cplus([a,b,c]);
c+b+a ;"
  :mma "cplus[{a,b,c}]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "(cplus=>Function(Apply(\"+\",Slot(1))));
lambda([[mixima_lambda_args]],Apply(\"+\",mix_nth(1,mixima_lambda_args))) ;"
  :mma "cplus = Plus @@ # &"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "f3(a,b,c,d);
f(a,b,c,d,X,b,c,d,Y,c,d,Z,d) ;"
  :mma "f3[a,b,c,d]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "(f3=>Function(f(SlotSequence(1),X,SlotSequence(2),Y,SlotSequence(3),Z,SlotSequence(4))));
lambda([[mixima_lambda_args]], mix_splice([1, 3, 5, 7],
f(SlotHold(1), X, SlotHold(2), Y, SlotHold(3), Z, SlotHold(4))))$"
  :mma "f3=f[##1,X,##2,Y,##3,Z,##4]&"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "f2(a,b,c,d);
f(b,c,d) ;"
  :mma "f2[a,b,c,d]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "(f2=>Function(f(SlotSequence(2))));
lambda([[mixima_lambda_args]], mix_splice([1], f(SlotHold(2))))$"
  :mma "f2=f[##2]&"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "f1(a,b,c,d);
f(a,b,c,d) ;"
  :mma "f1[a,b,c,d]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "(f1=>Function(f(SlotSequence(1))));
lambda([[mixima_lambda_args]], mix_splice([1], f(SlotHold(1))))$"
  :mma "f1=f[##]&"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Sort([[a,2],[c,1],[d,3]],Function((Part(Slot(1),2)<Part(Slot(2),2))));
[[c,1],[a,2],[d,3]] ;"
  :mma "Sort[ { {a,2}, {c,1}, {d,3} }, #1[[2]] < #2[[2]] & ]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Array(Function((1+(Slot(1)^2))),10);
[2,5,10,17,26,37,50,65,82,101] ;"
  :mma "Array[1 +#^2 &,10]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Select([1,-1,2,-2,3],Function((Slot(1)>0)));
[1,2,3] ;"
  :mma "Select[{1,-1,2,-2,3},#>0 &]"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :comments "parser has precedence wrong. parens are absent in original"
  :maxin ""
  :maxout "Map(Function(g(Slot(1),(Slot(1)^2))),[x,y,z]);
[g(x,x^2),g(y,y^2),g(z,z^2)] ;"
  :mma "(g[#,#^2]&) /@ {x,y,z}"
 ))

(help-item-add-example "Function"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((f=>Function((3+Slot(1)))),[f(a),f(b)]);
[a+3,b+3] ;"
  :mma "f=(3 +#)&;{f[a],f[b]}"
 ))

(help-item-init "ArcTan")

(help-item-add-example "ArcTan"
  (list 
  :type "ok"
  :maxin "ArcTan(-1,-1);"
  :maxout "-3*%pi/4;"
 ))

(help-item-add-example "ArcTan"
  (list 
  :type "ok"
  :maxin "ArcTan(1,1);"
  :maxout "%pi/4;"
 ))

(help-item-add-example "ArcTan"
  (list 
  :type "ok"
  :maxin "N(ArcTan(1)/Degree);"
  :maxout "45.0;"
 ))

(help-item-init "MatrixRank")

(help-item-add-example "MatrixRank"
  (list 
  :type "ok"
  :comments "Examples of MartrixRank with machine numbers , tolerance, etc.  are not implemented or fail"
  :maxin "MatrixRank(matrix([1,%i],[%i,-1]));"
  :maxout "1;"
 ))

(help-item-add-example "MatrixRank"
  (list 
  :type "ok"
  :maxin "MatrixRank([[1,%i],[%i,-1]]);"
  :maxout "1;"
 ))

(help-item-add-example "MatrixRank"
  (list 
  :type "br"
  :maxin "MatrixRank(float([[1,2,3],[4,5,6],[7,8,9]]));"
  :maxout ""
 ))

(help-item-add-example "MatrixRank"
  (list 
  :type "ok"
  :maxin "MatrixRank(matrix([a,b],[2*a,2*b]));"
  :maxout "1;"
 ))

(help-item-add-example "MatrixRank"
  (list 
  :type "ok"
  :maxin "MatrixRank([[a,b],[2*a,2*b]]);"
  :maxout "1;"
 ))

(help-item-add-example "MatrixRank"
  (list 
  :type "ok"
  :maxin "MatrixRank([[1,2,3],[4,5,6],[7,8,9]]);"
  :maxout "2;"
 ))

(help-item-add-example "MatrixRank"
  (list 
  :type "ok"
  :maxin "MatrixRank(matrix([1,2,3],[4,5,6],[7,8,9]));"
  :maxout "2;"
 ))

(help-item-init "Product")

(help-item-add-example "Product"
  (list 
  :type "br"
  :maxin "Product((1+(((i^2)+1)^-1)),[i,(-1*inf),inf]);"
  :maxout ""
 ))

(help-item-add-example "Product"
  (list 
  :type "br"
  :comments "fails to compute symbolic sums"
  :maxin "Product((1+((i^2)^-1)),[i,inf]);"
  :maxout ""
 ))

(help-item-add-example "Product"
  (list 
  :type "ok"
  :maxin "Product(f(i,j),[i,[a,b,c]],[j,1,3]);"
  :maxout "f(a,1)*f(a,2)*f(a,3)*f(b,1)*f(b,2)*f(b,3)*f(c,1)*f(c,2)*f(c,3);"
 ))

(help-item-add-example "Product"
  (list 
  :type "ok"
  :maxin "Product(f(i,j),[i,1,3],[j,1,i]);"
  :maxout "f(1,1)*f(2,1)*f(2,2)*f(3,1)*f(3,2)*f(3,3)$"
 ))

(help-item-add-example "Product"
  (list 
  :type "ok"
  :maxin "Product(f(i,j),[i,1,3,2],[j,1,3,1/2]);"
  :maxout "f(1,1)*f(1,3/2)*f(1,2)*f(1,5/2)*f(1,3)*f(3,1)*f(3,3/2)*f(3,2)*f(3,5/2)
*f(3,3);"
 ))

(help-item-add-example "Product"
  (list 
  :type "ok"
  :maxin "Product(f(i,j),[i,1,3],[j,1,3]);"
  :maxout "f(1,1)*f(1,2)*f(1,3)*f(2,1)*f(2,2)*f(2,3)*f(3,1)*f(3,2)*f(3,3);"
 ))

(help-item-add-example "Product"
  (list 
  :type "ok"
  :maxin "Product(f(i),[i,[a,b,c]]);"
  :maxout "f(a)*f(b)*f(c);"
 ))

(help-item-add-example "Product"
  (list 
  :type "ok"
  :maxin "Product(f(i),[i,1,4,2]);"
  :maxout "f(1)*f(3);"
 ))

(help-item-add-example "Product"
  (list 
  :type "ok"
  :maxin "Product(f(i),[i,1,4]);"
  :maxout "f(1)*f(2)*f(3)*f(4);"
 ))

(help-item-add-example "Product"
  (list 
  :type "ok"
  :maxin "Product((i),[i,1,n]);"
  :maxout "n!;"
 ))

(help-item-add-example "Product"
  (list 
  :type "ok"
  :maxin "Product((i^2),[i,1,6]);"
  :maxout "518400;"
 ))

(help-item-init "FoldList")

(help-item-add-example "FoldList"
  (list 
  :type "ok"
  :comments "continued fraction"
  :maxin "FoldList(lambda([x,y], 1/(y + x)), x, Reverse([a, b, c]));"
  :maxout "[x,1/(x+c),1/(1/(x+c)+b),1/(1/(1/(x+c)+b)+a)];"
 ))

(help-item-add-example "FoldList"
  (list 
  :type "ok"
  :comments "successive factorials"
  :maxin "FoldList(\"*\",1,Range(10));"
  :maxout "[1,1,2,6,24,120,720,5040,40320,362880,3628800];"
 ))

(help-item-add-example "FoldList"
  (list 
  :type "ok"
  :maxin "FoldList(lambda([x,y], g(y,x)), x, [a,b,c,d]);"
  :maxout "[x,g(a,x),g(b,g(a,x)),g(c,g(b,g(a,x))),g(d,g(c,g(b,g(a,x))))];"
 ))

(help-item-add-example "FoldList"
  (list 
  :type "ok"
  :maxin "FoldList(lambda([x,y], x^y),x,[a,b,c,d]);"
  :maxout "[x,x^a,(x^a)^b,((x^a)^b)^c,(((x^a)^b)^c)^d];"
 ))

(help-item-add-example "FoldList"
  (list 
  :type "ok"
  :maxin "FoldList(\"+\",0,[a,b,c,d]);"
  :maxout "[0,a,b+a,c+b+a,d+c+b+a];"
 ))

(help-item-add-example "FoldList"
  (list 
  :type "ok"
  :maxin "FoldList(f,x,[a,b,c,d]);"
  :maxout "[x,f(x,a),f(f(x,a),b),f(f(f(x,a),b),c),f(f(f(f(x,a),b),c),d)];"
 ))

(help-item-init "NextPrime")

(help-item-add-example "NextPrime"
  (list 
  :type "ok"
  :maxin "NextPrime(2,-1);"
  :maxout "-2;"
 ))

(help-item-add-example "NextPrime"
  (list 
  :type "ok"
  :maxin "NextPrime(100,-3);"
  :maxout "83;"
 ))

(help-item-add-example "NextPrime"
  (list 
  :type "ok"
  :maxin "NextPrime(5,-1);"
  :maxout "3;"
 ))

(help-item-add-example "NextPrime"
  (list 
  :type "ok"
  :maxin "NextPrime(5,1);"
  :maxout "7;"
 ))

(help-item-add-example "NextPrime"
  (list 
  :type "ok"
  :maxin "NextPrime(5.1);"
  :maxout "7;"
 ))

(help-item-add-example "NextPrime"
  (list 
  :type "ok"
  :maxin "NextPrime(4.9);"
  :maxout "5;"
 ))

(help-item-add-example "NextPrime"
  (list 
  :type "ok"
  :maxin "NextPrime(5);"
  :maxout "7;"
 ))

(help-item-init "Conjugate")

(help-item-add-example "Conjugate"
  (list 
  :type "br"
  :comments "expected: infinity
 returns: conjugate(infinity)."
  :maxin "Conjugate(infinity);"
  :maxout ""
 ))

(help-item-add-example "Conjugate"
  (list 
  :type "br"
  :comments "This gives the right answer, but asks if 1 is 0."
  :maxin "Conjugate((%i*inf));"
  :maxout ""
 ))

(help-item-add-example "Conjugate"
  (list 
  :type "ok"
  :maxin "Conjugate([(-1-%i),0,(1+%i)]);"
  :maxout "[%i-1,0,1-%i];"
 ))

(help-item-add-example "Conjugate"
  (list 
  :type "ok"
  :maxin "Conjugate((2-(1.6*%i)));"
  :maxout "1.6*%i+2;"
 ))

(help-item-add-example "Conjugate"
  (list 
  :type "ni"
  :maxin "Root(lambda( [arg1], (5+(3*(arg1^2))+(5*(arg1^6))) ),4);"
  :maxout ""
 ))

(help-item-add-example "Conjugate"
  (list 
  :type "ok"
  :maxin "Conjugate(Exp((%i*%pi*1/4)));"
  :maxout "1/sqrt(2)-%i/sqrt(2);"
 ))

(help-item-add-example "Conjugate"
  (list 
  :type "ok"
  :maxin "Conjugate((1+%i));"
  :maxout "1-%i;"
 ))

(help-item-init "ReplacePart")

(help-item-add-example "ReplacePart"
  (list 
  :type "ok"
  :comments "This seems to be an undocumented usage that comes from user code"
  :maxin "ReplacePart([1,2,3,4,5],z,[3]);"
  :maxout "[1,2,z,4,5];"
 ))

(help-item-init "Take")

(help-item-add-example "Take"
  (list 
  :type "ok"
  :comments "reverse a list. but this is extremely inefficient
 at least for large arrays in the current implementation."
  :maxin "Take(Range(10),[-1,1,-1]);"
  :maxout "[10,9,8,7,6,5,4,3,2,1];"
 ))

(help-item-add-example "Take"
  (list 
  :type "ok"
  :maxin "Take((a + b + c) * (t + u + v) * (x + y + z), 2, 2);"
  :maxout "(c+b)*(v+u);"
 ))

(help-item-add-example "Take"
  (list 
  :type "ok"
  :maxin "Take( [a+b+c, t+u+v , x+y+z],2,2);"
  :maxout "[c+b,v+u];"
 ))

(help-item-add-example "Take"
  (list 
  :type "ok"
  :comments "Mma does not reorder the list"
  :maxin "Take(a + b + c + d + e + f, 3);"
  :maxout "f+e+d;"
 ))

(help-item-add-example "Take"
  (list 
  :type "ok"
  :comments "Take every other row and every other column."
  :maxin "Take(Partition(Range(11,55),5), [1,-1,2], [1,-1,2]);"
  :maxout "[[11,13,15],[21,23,25],[31,33,35],[41,43,45],[51,53,55]];"
 ))

(help-item-add-example "Take"
  (list 
  :type "ok"
  :comments "Takes second through fourth at the top level and third through fifth at  the next level."
  :maxin "Take(Partition(Range(11,55),5), [2,4], [3,5]);"
  :maxout "[[18,19,20],[23,24,25],[28,29,30]];"
 ))

(help-item-add-example "Take"
  (list 
  :type "ok"
  :comments "Take last element of the each of the first two lists."
  :maxin "Take([[11, 12, 13], [21, 22, 23], [31, 32, 33]], 2, -1);"
  :maxout "[[13],[23]];"
 ))

(help-item-add-example "Take"
  (list 
  :type "ok"
  :maxin "Take([[11, 12, 13], [21, 22, 23], [31, 32, 33]], 3, 2);"
  :maxout "[[11,12],[21,22],[31,32]];"
 ))

(help-item-add-example "Take"
  (list 
  :type "ok"
  :comments "elements here are lists. Take is taking the first  two top-level lists."
  :maxin "Take([[11, 12, 13], [21, 22, 23], [31, 32, 33]], 2);"
  :maxout "[[11,12,13],[21,22,23]];"
 ))

(help-item-add-example "Take"
  (list 
  :type "ok"
  :comments "Take second through second-to-last elements"
  :maxin "Take([a, b, c, d, e, f], [2, -2]);"
  :maxout "[b,c,d,e];"
 ))

(help-item-add-example "Take"
  (list 
  :type "ok"
  :comments "Take second through fourth elements"
  :maxin "Take([a, b, c, d, e, f], [2, 4]);"
  :maxout "[b,c,d];"
 ))

(help-item-add-example "Take"
  (list 
  :type "ok"
  :comments "Take last three elements"
  :maxin "Take([a, b, c, d, e, f], -3);"
  :maxout "[d,e,f];"
 ))

(help-item-add-example "Take"
  (list 
  :type "ok"
  :comments "Take first four elements"
  :maxin "Take([a, b, c, d, e, f], 4);"
  :maxout "[a,b,c,d];"
 ))

(help-item-init "FromDigits")

(help-item-add-example "FromDigits"
  (list 
  :type "ok"
  :comments "digits larger than base are carried"
  :maxin "FromDigits([7, 11, 0, 0, 0, 122]);"
  :maxout "810122;"
 ))

(help-item-add-example "FromDigits"
  (list 
  :type "ok"
  :comments "Mma wrapped this with expand, which we don't need"
  :maxin "FromDigits([a, b, c, d, e], x);"
  :maxout "a*x^4+b*x^3+c*x^2+d*x+e;"
 ))

(help-item-add-example "FromDigits"
  (list 
  :type "ok"
  :maxin "FromDigits([1, 0, 1, 1, 0, 1, 1], 2);"
  :maxout "91;"
 ))

(help-item-add-example "FromDigits"
  (list 
  :type "ok"
  :maxin "FromDigits([5, 1, 2, 8]);"
  :maxout "5128;"
 ))

(help-item-init "Integrate")

(help-item-add-example "Integrate"
  (list 
  :type "br"
  :comments "error"
  :maxin "Integrate(Sin(Tan(x)),x);"
  :maxout ""
 ))

(help-item-add-example "Integrate"
  (list 
  :type "br"
  :maxin "Integrate(Erf(x),x);"
  :maxout ""
 ))

(help-item-add-example "Integrate"
  (list 
  :type "br"
  :maxin "Integrate(SinhIntegral((2*((x+1)^-1))),x);"
  :maxout ""
 ))

(help-item-add-example "Integrate"
  (list 
  :type "br"
  :maxin "Integrate((Tan(x)^n),x);"
  :maxout ""
 ))

(help-item-add-example "Integrate"
  (list 
  :type "br"
  :maxin "Integrate((Log(x)*Exp((-1*(x^2)))),x);"
  :maxout ""
 ))

(help-item-add-example "Integrate"
  (list 
  :type "br"
  :maxin "Integrate((Log(x)*Exp((-1*(x^2)))),x);"
  :maxout ""
 ))

(help-item-add-example "Integrate"
  (list 
  :type "br"
  :maxin "Integrate(Sqrt((x+Sqrt(x))),x);"
  :maxout ""
 ))

(help-item-add-example "Integrate"
  (list 
  :type "ok"
  :comments "partial sucess"
  :maxin "Integrate(Log(Log(x)),x);"
  :maxout "x*log(log(x))+gamma_incomplete(0,-log(x));"
 ))

(help-item-add-example "Integrate"
  (list 
  :type "ok"
  :comments "note Mma has FullSimplify here"
  :maxin "Simplify(D(Integrate((((x^2)+4)^-1),x,x),x,x));"
  :maxout "1/(x^2+4);"
 ))

(help-item-add-example "Integrate"
  (list 
  :type "ok"
  :maxin "Integrate(AiryAi(x),x);"
  :maxout "hypergeometric([1/3],[2/3,4/3],x^3/9)*x/(3^(2/3)*gamma(2/3))
-3^(1/6)*gamma(2/3)*hypergeometric([2/3],[4/3,5/3],x^3/9)*x^2/(4*%pi);"
 ))

(help-item-add-example "Integrate"
  (list 
  :type "ok"
  :maxin "Integrate(BesselJ(0,x),x);"
  :maxout "(bessel_j(0,x)*(2-%pi*struve_h(1,x))+%pi*struve_h(0,x)*bessel_j(1,x))*x/2;"
 ))

(help-item-add-example "Integrate"
  (list 
  :type "ok"
  :maxin "Integrate(((Log((1+x))^2)*(x^-1)),x);"
  :maxout "-2*(-log(-x)*log(x+1)^2/2-li[2](x+1)*log(x+1)+li[3](x+1));"
 ))

(help-item-add-example "Integrate"
  (list 
  :type "ok"
  :maxin "Integrate(Exp((-1*(x^2))),x);"
  :maxout "sqrt(%pi)*erf(x)/2;"
 ))

(help-item-add-example "Integrate"
  (list 
  :type "ok"
  :maxin "Integrate((Sqrt(x)*Sqrt((1+x))),x);"
  :maxout "-log(sqrt(x+1)/sqrt(x)+1)/8+log(sqrt(x+1)/sqrt(x)-1)/8
+((x+1)^(3/2)/x^(3/2)+sqrt(x+1)/sqrt(x))
/(4*(x+1)^2/x^2-8*(x+1)/x+4);"
 ))

(help-item-add-example "Integrate"
  (list 
  :type "ok"
  :comments "note Integrand is rational function"
  :maxin "Integrate((((x^4)-1)^-1),x);"
  :maxout "-log(x+1)/4-atan(x)/2+log(x-1)/4;"
 ))

(help-item-add-example "Integrate"
  (list 
  :type "br"
  :comments "partial success. need assumption on x"
  :maxin "Integrate(Sin(x* y), [x, 0, 1], [y, 0, x]);"
  :maxout "-'limit(log(y)+gamma_incomplete(0,%i*y)/2+gamma_incomplete(0,-%i*y)/2,
y,0,plus)
+log(x)+gamma_incomplete(0,%i*x)/2+gamma_incomplete(0,-%i*x)/2;"
 ))

(help-item-add-example "Integrate"
  (list 
  :type "ok"
  :maxin "Integrate((((x^3)+1)^-1),[x,0,1]);"
  :maxout "(6*log(2)+sqrt(3)*%pi)/18+%pi/(2*3^(3/2));"
 ))

(help-item-add-example "Integrate"
  (list 
  :type "ok"
  :maxin "Integrate((((x^3)+1)^-1),x);"
  :maxout "-log(x^2-x+1)/6+atan((2*x-1)/sqrt(3))/sqrt(3)+log(x+1)/3;"
 ))

(help-item-add-example "Integrate"
  (list 
  :type "br"
  :comments "fix this. needs assume x>0"
  :maxin "Integrate(Sin(x*y),x, y);"
  :maxout "(gamma_incomplete(0,%i*x*y)+gamma_incomplete(0,-%i*x*y))/2;"
 ))

(help-item-add-example "Integrate"
  (list 
  :type "ok"
  :comments "note Multiple integrals"
  :maxin "Integrate((((x^2)+4)^-1),x,x);"
  :maxout "(x*atan(x/2)-log(x^2/4+1))/2;"
 ))

(help-item-init "Range")

(help-item-add-example "Range"
  (list 
  :type "ok"
  :comments "We need to put in asssume. but Mma ex. does not, and   gives the same answer."
  :maxin "block( [a,b], assume(b>a), Range(a,b,(b-a)/4));"
  :maxout "[a,(b-a)/4+a,(b-a)/2+a,3*(b-a)/4+a,b];"
 ))

(help-item-add-example "Range"
  (list 
  :type "ok"
  :maxin "Range(x,x+4);"
  :maxout "[x,x+1,x+2,x+3,x+4];"
 ))

(help-item-add-example "Range"
  (list 
  :type "ok"
  :maxin "Range(1.2,2.2,.15);"
  :maxout "[1.2,1.35,1.5,1.65,1.8,1.95,2.1];"
 ))

(help-item-add-example "Range"
  (list 
  :type "ok"
  :maxin "Range(4);"
  :maxout "[1,2,3,4];"
 ))

(help-item-init "Part")

(help-item-add-example "Part"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Part(Array(lambda( [[lambda_args]],  (lambda_args[1]+lambda_args[2]) ),[3,3]),1,2);
3 ;"
  :mma "Part[Array[#1+#2 &,{3,3}],1,2 ]"
 ))

(help-item-add-example "Part"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Part([a,b,c],-1);
c ;"
  :mma "Part[{a,b,c},-1]"
 ))

(help-item-add-example "Part"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Part([a,b,c],1);
a ;"
  :mma "Part[{a,b,c},1]"
 ))

(help-item-add-example "Part"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Part(Array(lambda( [[lambda_args]],  (lambda_args[1]+lambda_args[2]) ),[3,3]),1,2);
3 ;"
  :mma "Part[Array[#1+#2 &,{3,3}],1,2 ]"
 ))

(help-item-add-example "Part"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Part([a,b,c],-1);
c ;"
  :mma "Part[{a,b,c},-1]"
 ))

(help-item-add-example "Part"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Part([a,b,c],1);
a ;"
  :mma "Part[{a,b,c},1]"
 ))

(help-item-init "While")

(help-item-add-example "While"
  (list 
  :type "ok"
  :comments "only two args; no body"
  :maxin "(i : 10, c:0, While( (i:i-1,c:c+i,i>0) ), c);"
  :maxout "45$"
 ))

(help-item-add-example "While"
  (list 
  :type "ok"
  :maxin "(i : 10, c:0, While(i>0, (i:i-1,c:c+i)), c);"
  :maxout "45$"
 ))

(help-item-init "*/")

(help-item-add-example "*/"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table([i(j),(j+1)],[j,3]);
[[i(1),2],[i(2),3],[i(3),4]] ;"
  :mma "Table[{i[j],j+1},{j,3}]"
 ))

(help-item-init "ConstantArray")

(help-item-add-example "ConstantArray"
  (list 
  :type "ok"
  :maxin ""
  :maxout "ConstantArray(x,[2,1,2,1,2]);
[[[[[x,x]],[[x,x]]]],[[[[x,x]],[[x,x]]]]] ;"
  :mma "ConstantArray[x,{2,1,2,1,2}]"
 ))

(help-item-add-example "ConstantArray"
  (list 
  :type "ok"
  :maxin ""
  :maxout "ConstantArray(0,[3,3]);
[[0,0,0],[0,0,0],[0,0,0]] ;"
  :mma "ConstantArray[0,{3,3}]"
 ))

(help-item-add-example "ConstantArray"
  (list 
  :type "ok"
  :maxin ""
  :maxout "ConstantArray(0,10);
[0,0,0,0,0,0,0,0,0,0] ;"
  :mma "ConstantArray[0,10]"
 ))

(help-item-add-example "ConstantArray"
  (list 
  :type "ok"
  :maxin ""
  :maxout "ConstantArray(0.0,10);
[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0] ;"
  :mma "ConstantArray[0.,10]"
 ))

(help-item-add-example "ConstantArray"
  (list 
  :type "ok"
  :maxin ""
  :maxout "ConstantArray(c,[3,4]);
[[c,c,c,c],[c,c,c,c],[c,c,c,c]] ;"
  :mma "ConstantArray[c,{3,4}]"
 ))

(help-item-add-example "ConstantArray"
  (list 
  :type "ok"
  :maxin ""
  :maxout "ConstantArray(c,10);
[c,c,c,c,c,c,c,c,c,c] ;"
  :mma "ConstantArray[c,10]"
 ))

(help-item-init "Simplify")

(help-item-add-example "Simplify"
  (list 
  :type "br"
  :comments "This is not the answer that Mma gives.
 Simplifying with equations and with other options and assumptions is not implemented"
  :maxin "Simplify(((4*(Sin(x)^2)*(Cos(x)^2))+(4*Sin(x)*Cos(x))+1));"
  :maxout "-(cos(4*x)-4*sin(2*x)-3)/2"
 ))

(help-item-add-example "Simplify"
  (list 
  :type "ok"
  :maxin "Simplify((E^x - E^-x)/Sinh(x));"
  :maxout "2;"
 ))

(help-item-add-example "Simplify"
  (list 
  :type "ok"
  :maxin "Simplify(2* Tan(x)/(1 + Tan(x)^2));"
  :maxout "sin(2*x);"
 ))

(help-item-add-example "Simplify"
  (list 
  :type "ok"
  :maxin "Simplify((x - 1)* (x + 1) *(x^2 + 1) + 1);"
  :maxout "x^4;"
 ))

(help-item-add-example "Simplify"
  (list 
  :type "ok"
  :maxin "Simplify(D(Integrate(1/(x^3 + 1), x), x));"
  :maxout "1/(x^3+1);"
 ))

(help-item-add-example "Simplify"
  (list 
  :type "ok"
  :maxin "Simplify(Cos(x)^2+Sin(x)^2);"
  :maxout "1;"
 ))

(help-item-init "Eigenvalues")

(help-item-add-example "Eigenvalues"
  (list 
  :type "ok"
  :maxin "Eigenvalues( matrix( [1,0,0], [0,1,0], [0,0,1]));"
  :maxout "[1,1,1];"
 ))

(help-item-add-example "Eigenvalues"
  (list 
  :type "ok"
  :maxin "Eigenvalues( [ [1,0,0], [0,1,0], [0,0,1]]);"
  :maxout "[1,1,1];"
 ))

(help-item-add-example "Eigenvalues"
  (list 
  :type "ok"
  :maxin "is( ratsimp(Eigenvalues(matrix([a,b],[c,d]))) =
ratsimp([-(sqrt(d^2-2*a*d+4*b*c+a^2)-d-a)/2,(sqrt(d^2-2*a*d+4*b*c+a^2)+d+a)/2]));"
  :maxout "true;"
 ))

(help-item-add-example "Eigenvalues"
  (list 
  :type "ok"
  :maxin "is( ratsimp(Eigenvalues([[a,b],[c,d]])) =
ratsimp([-(sqrt(d^2-2*a*d+4*b*c+a^2)-d-a)/2,(sqrt(d^2-2*a*d+4*b*c+a^2)+d+a)/2]));"
  :maxout "true;"
 ))

(help-item-init "ArcCos")

(help-item-add-example "ArcCos"
  (list 
  :type "ok"
  :maxin "Series(ArcCos(x),[x,0,10]);"
  :maxout "%pi/2-x-x^3/6-3*x^5/40-5*x^7/112-35*x^9/1152;"
 ))

(help-item-add-example "ArcCos"
  (list 
  :type "ok"
  :maxin "ArcCos(0);"
  :maxout "%pi/2;"
 ))

(help-item-init "FindRoot")

(help-item-add-example "FindRoot"
  (list 
  :type "ni"
  :maxin ""
  :maxout ""
 ))

(help-item-add-example "FindRoot"
  (list 
  :type "ni"
  :maxin ""
  :maxout ""
  :mma "FindRoot[{Exp[x - 2] == y, y^2 == x}, {{x, 1}, {y, 1}}]"
 ))

(help-item-add-example "FindRoot"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Chop((inpart(FindRoot((Cos(x)=x),[x,0]),1,2)-0.73908513338528403));
0 ;"
  :mma "Chop[Part[FindRoot[Cos[x]==x,{x,0}],1,2]-0.73908513338528403]"
 ))

(help-item-add-example "FindRoot"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Chop((inpart(FindRoot((Sin(x)+Exp(x)),[x,0]),1,2)+0.58853274397739996));
0 ;"
  :mma "Chop[Part[FindRoot[Sin[x]+Exp[x],{x,0}],1,2]+0.5885327439774]"
 ))

(help-item-init "Dot")

(help-item-add-example "Dot"
  (list 
  :type "ok"
  :comments "Tensors are implemented"
  :maxin "Dimensions(Dot(Array(a,[2,3,4]),Array(b,[4,2,2]),Array(c,[2,1])));"
  :maxout "[2,3,2,1];"
 ))

(help-item-add-example "Dot"
  (list 
  :type "ok"
  :comments "Following are not mma examples"
  :maxin "Dot(IdentityMatrix(3),IdentityMatrix(3),IdentityMatrix(3),IdentityMatrix(3));"
  :maxout "[[1,0,0],[0,1,0],[0,0,1]];"
 ))

(help-item-add-example "Dot"
  (list 
  :type "ok"
  :maxin "Dot([[a,b],[c,d]],[[r,s],[t,u]]);"
  :maxout "[[b*t+a*r,b*u+a*s],[d*t+c*r,d*u+c*s]];"
 ))

(help-item-add-example "Dot"
  (list 
  :type "ok"
  :maxin "Dot([x,y],[[a,b],[c,d]],[r,s]);"
  :maxout "s*(d*y+b*x)+r*(c*y+a*x);"
 ))

(help-item-add-example "Dot"
  (list 
  :type "ok"
  :maxin "Dot([x,y],[[a,b],[c,d]]);"
  :maxout "[c*y+a*x,d*y+b*x];"
 ))

(help-item-add-example "Dot"
  (list 
  :type "ok"
  :maxin "Dot([[a,b],[c,d]],[x,y]);"
  :maxout "[b*y+a*x,d*y+c*x];"
 ))

(help-item-add-example "Dot"
  (list 
  :type "ok"
  :maxin "Dot([a,b,c],[x,y,z]);"
  :maxout "c*z+b*y+a*x;"
 ))

(help-item-init "Join")

(help-item-add-example "Join"
  (list 
  :type "ok"
  :maxin "Join([[a, b], [c, d]], [[1, 2], [3, 4]]);"
  :maxout "[[a,b],[c,d],[1,2],[3,4]];"
 ))

(help-item-add-example "Join"
  (list 
  :type "ok"
  :maxin "Join([a,b,c],[x,y],[u,v,w]);"
  :maxout "[a,b,c,x,y,u,v,w];"
 ))

(help-item-init "SignaturePermutation")

(help-item-add-example "SignaturePermutation"
  (list 
  :type "ok"
  :comments "Compute all permutations of 1..7, Sum the signatures.
 There are equal numbers of even and odd permutations.
 This goes much faster if we do compile(SignaturePermutation).
 Careful: the example writing code stripped the \"\" from the +."
  :maxin ""
  :maxout "Apply(\"+\",Map(SignaturePermutation,Permutations(Range(7))));
0 ;"
  :mma "Apply[\"+\",Map[SignaturePermutation,Permutations[Range[7]]]]"
 ))

(help-item-add-example "SignaturePermutation"
  (list 
  :type "ok"
  :maxin ""
  :maxout "SignaturePermutation([3,2,1]);
- 1 ;"
  :mma "SignaturePermutation[{3,2,1}]"
 ))

(help-item-add-example "SignaturePermutation"
  (list 
  :type "ok"
  :maxin ""
  :maxout "SignaturePermutation([2,1,3]);
- 1 ;"
  :mma "SignaturePermutation[{2,1,3}]"
 ))

(help-item-add-example "SignaturePermutation"
  (list 
  :type "ok"
  :maxin ""
  :maxout "SignaturePermutation([1,2,3]);
1 ;"
  :mma "SignaturePermutation[{1,2,3}]"
 ))

(help-item-init "Nest")

(help-item-add-example "Nest"
  (list 
  :type "ok"
  :comments "wrap this in Chop to deal with floating point imprecision"
  :maxin "Chop(Nest( lambda([x], [(x[1] + x[2])/2, sqrt(x[1]*x[2])]), [0.5, 1.0], 10)
- [0.72839551552345,0.72839551552345] , 1e-14);"
  :maxout "[0,0];"
 ))

(help-item-add-example "Nest"
  (list 
  :type "ok"
  :maxin "Nest(sqrt,100.0,4);"
  :maxout "1.333521432163324;"
 ))

(help-item-add-example "Nest"
  (list 
  :type "ok"
  :maxin "Nest(lambda([x],(1 + x)^2) , x, 5);"
  :maxout "(((((x+1)^2+1)^2+1)^2+1)^2+1)^2;"
 ))

(help-item-add-example "Nest"
  (list 
  :type "ok"
  :maxin "Nest(lambda([x],(1 + x)^2) , 1, 3);"
  :maxout "676;"
 ))

(help-item-add-example "Nest"
  (list 
  :type "ok"
  :maxin "Nest(f,x,3);"
  :maxout "f(f(f(x)));"
 ))

(help-item-init "Riffle")

(help-item-add-example "Riffle"
  (list 
  :type "ok"
  :maxin "Riffle([a,b,c],[x,y,z]);"
  :maxout "[a,x,b,y,c,z];"
 ))

(help-item-init "Characters")

(help-item-add-example "Characters"
  (list 
  :type "br"
  :comments "Mma has spaces around the +; this works but with no spaces."
  :maxin "Characters(ToString(x + y));"
  :maxout "[\"y\",\"+\",\"x\"];"
 ))

(help-item-add-example "Characters"
  (list 
  :type "br"
  :comments "Mma returns this unevaluated. This implementation returns errors"
  :maxin "Characters(x + y);"
  :maxout ""
 ))

(help-item-add-example "Characters"
  (list 
  :type "ok"
  :maxin "Sort(Characters(\"this is a string\"));"
  :maxout "[\" \",\" \",\" \",\"a\",\"g\",\"h\",\"i\",\"i\",\"i\",\"n\",\"r\",\"s\",\"s\",\"s\",\"t\",\"t\"];"
 ))

(help-item-add-example "Characters"
  (list 
  :type "ok"
  :maxin "StringJoin(Partition(Characters(\"this is a string\"), 3, 1));"
  :maxout "\"thihisis s i isis s a a a s ststrtririning\";"
 ))

(help-item-add-example "Characters"
  (list 
  :type "ok"
  :maxin "Partition(Characters(\"this is a string\"), 3, 1);"
  :maxout "[[\"t\",\"h\",\"i\"],[\"h\",\"i\",\"s\"],[\"i\",\"s\",\" \"],[\"s\",\" \",\"i\"],
[\" \",\"i\",\"s\"],[\"i\",\"s\",\" \"],[\"s\",\" \",\"a\"],[\" \",\"a\",\" \"],
[\"a\",\" \",\"s\"],[\" \",\"s\",\"t\"],[\"s\",\"t\",\"r\"],[\"t\",\"r\",\"i\"],
[\"r\",\"i\",\"n\"],[\"i\",\"n\",\"g\"]];"
 ))

(help-item-add-example "Characters"
  (list 
  :type "ni"
  :maxin "Characters([\"ABC\", \"DEF\", \"XYZ\"]);"
  :maxout ""
 ))

(help-item-add-example "Characters"
  (list 
  :type "ok"
  :maxin "StringJoin(Characters(\"A string.\"));"
  :maxout "\"A string.\";"
 ))

(help-item-add-example "Characters"
  (list 
  :type "ok"
  :maxin "Characters(\"A string.\");"
  :maxout "[\"A\",\" \",\"s\",\"t\",\"r\",\"i\",\"n\",\"g\",\".\"];"
 ))

(help-item-init "ConjugateTranspose")

(help-item-add-example "ConjugateTranspose"
  (list 
  :type "ok"
  :maxin "ConjugateTranspose([[1,(2*%i),3],[(3+(4*%i)),5,%i]]);"
  :maxout "[[1,3-4*%i],[-2*%i,5],[3,-%i]];"
 ))

(help-item-init "Transpose")

(help-item-add-example "Transpose"
  (list 
  :type "ok"
  :maxin "Transpose(Array(a,[2,1,1]),[3,1,2]);"
  :maxout "[[[a(1,1,1),a(2,1,1)]]];"
 ))

(help-item-add-example "Transpose"
  (list 
  :type "ok"
  :maxin "Transpose(Array(a,[3,1,1],[3,1,2]));"
  :maxout "[[[a(3,1,2)],[a(4,1,2)],[a(5,1,2)]]];"
 ))

(help-item-add-example "Transpose"
  (list 
  :type "ok"
  :comments "returns ordinary list."
  :maxin "Transpose([ [1,2,3],[4,5,6],[7,8,9] ]);"
  :maxout "[[1,4,7],[2,5,8],[3,6,9]];"
 ))

(help-item-add-example "Transpose"
  (list 
  :type "ok"
  :comments "returns type matrix"
  :maxin "Transpose(matrix([1,2,3],[4,5,6],[7,8,9]));"
  :maxout "matrix([1,4,7],[2,5,8],[3,6,9]);"
 ))

(help-item-init "Tuples")

(help-item-add-example "Tuples"
  (list 
  :type "ok"
  :maxin "Map(lambda([x],FromDigits(x,2)),Tuples([0,1],4));"
  :maxout "[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];"
 ))

(help-item-add-example "Tuples"
  (list 
  :type "ok"
  :maxin "Map(StringJoin,Tuples([\"A\",\"B\"],3));"
  :maxout "[\"AAA\",\"AAB\",\"ABA\",\"ABB\",\"BAA\",\"BAB\",\"BBA\",\"BBB\"];"
 ))

(help-item-add-example "Tuples"
  (list 
  :type "ok"
  :maxin "Tuples([f[a,b,c],f[0,1]]);"
  :maxout "[f[a,0],f[a,1],f[b,0],f[b,1],f[c,0],f[c,1]];"
 ))

(help-item-add-example "Tuples"
  (list 
  :type "ok"
  :maxin "Tuples(f[a,b,c],2);"
  :maxout "[f[a,a],f[a,b],f[a,c],f[b,a],f[b,b],f[b,c],f[c,a],f[c,b],f[c,c]];"
 ))

(help-item-add-example "Tuples"
  (list 
  :type "ok"
  :maxin "Tuples([[a, b], [1, 2, 3, 4], [x]]);"
  :maxout "[[a,1,x],[a,2,x],[a,3,x],[a,4,x],[b,1,x],[b,2,x],[b,3,x],[b,4,x]];"
 ))

(help-item-add-example "Tuples"
  (list 
  :type "ok"
  :maxin "Tuples([a,a,b],2);"
  :maxout "[[a,a],[a,a],[a,b],[a,a],[a,a],[a,b],[b,a],[b,a],[b,b]];"
 ))

(help-item-add-example "Tuples"
  (list 
  :type "ok"
  :maxin "Tuples([1,0],2);"
  :maxout "[[1,1],[1,0],[0,1],[0,0]];"
 ))

(help-item-add-example "Tuples"
  (list 
  :type "ok"
  :maxin "Tuples([0,1],2);"
  :maxout "[[0,0],[0,1],[1,0],[1,1]];"
 ))

(help-item-init "Limit")

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit((1 + x/n)^n, Rule(n,Infinity));"
  :maxout "%e^x;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit(((x*y)*(((x^2)+(y^2))^-1)),Rule(y,0));"
  :maxout "0;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit(((x*y)*(((x^2)+(y^2))^-1)),Rule(x,0));"
  :maxout "0;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit((x*Sin((x^-1))),Rule(x,0));"
  :maxout "0;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit(Tan(x),Rule(x,(Pi*1/2)),Rule(Direction,-1));"
  :maxout "minf;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit(Tan(x),Rule(x,(Pi*1/2)),Rule(Direction,1));"
  :maxout "inf;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit((x^-1),Rule(x,0),Rule(Direction,-1));"
  :maxout "inf;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit((x^-1),Rule(x,0),Rule(Direction,1));"
  :maxout "minf;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "br"
  :maxin "Limit((BesselI(1,(3*x))*((x*(BesselI(1,x)^3))^-1)),Rule(x,Infinity));"
  :maxout ""
 ))

(help-item-add-example "Limit"
  (list 
  :type "br"
  :comments "Wrong!"
  :maxin "Limit((Gamma((x+1/2))*(Gamma(x)^-1)*(Sqrt(x)^-1)),Rule(x,Infinity));"
  :maxout "inf;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit(((factorial(n)^(n^-1))*(n^-1)),Rule(n,Infinity));"
  :maxout "%e^(-1);"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit((Exp(x)*(Exp(((x^-1)-Exp((-1*x))))-Exp((x^-1)))),Rule(x,Infinity));"
  :maxout "-1;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit((x*Log((x^2))),Rule(x,0));"
  :maxout "0;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit((Sin((2*x))*(Sin(x)^-1)),Rule(x,0));"
  :maxout "2;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit((Sqrt((x-1))*(x^-1)),Rule(x,1));"
  :maxout "0;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit(((x-3)*((Sqrt(x)-3)^-1)),Rule(x,9));"
  :maxout "infinity;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit((Sqrt((y-x))*(Sqrt((1+x))^-1)),Rule(x,Infinity));"
  :maxout "%i;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit(((x-4)^-1),Rule(x,4));"
  :maxout "infinity;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit((((x^2)-(2*x)-8)*((x-4)^-1)),Rule(x,4));"
  :maxout "6;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit(((1+(x*(n^-1)))^n),Rule(n,Infinity));"
  :maxout "%e^x;"
 ))

(help-item-add-example "Limit"
  (list 
  :type "ok"
  :maxin "Limit((Sin(x)*(x^-1)),Rule(x,0));"
  :maxout "1;"
 ))

(help-item-init "Apply")

(help-item-add-example "Apply"
  (list 
  :type "ni"
  :maxin ""
  :maxout ""
 ))

(help-item-add-example "Apply"
  (list 
  :type "ni"
  :maxin ""
  :maxout ""
  :mma "Apply[f, {{{{{a}}}}}, -1]"
 ))

(help-item-add-example "Apply"
  (list 
  :type "ni"
  :maxin ""
  :maxout ""
  :mma "Apply[f, {{a, b, c}, {d, e}}, {1}]"
 ))

(help-item-add-example "Apply"
  (list 
  :type "ok"
  :maxin "Apply(f,[[a, b], [c], d]);"
  :maxout "f([a,b],[c],d);"
 ))

(help-item-add-example "Apply"
  (list 
  :type "ok"
  :maxin "Apply(Plus,g[x,y,z]);"
  :maxout "z+y+x;"
 ))

(help-item-add-example "Apply"
  (list 
  :type "ok"
  :maxin "Apply(Plus,[a,b,c,d]);"
  :maxout "d + c + b + a;"
 ))

(help-item-add-example "Apply"
  (list 
  :type "ok"
  :maxin "Apply(f,[a,b,c,d]);"
  :maxout "f(a, b, c, d);"
 ))

(help-item-init "MapAt")

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :comments "negative indices supported"
  :maxin ""
  :maxout "MapAt(h,[[a,b,c],[d,e],f,g],-3);
[[a,b,c],h([d,e]),f,g] ;"
  :mma "MapAt[h,{{a,b,c},{d,e},f,g},-3]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table(MapAt(f,[a,b,c,d],i),[i,4]);
[[f(a),b,c,d],[a,f(b),c,d],[a,b,f(c),d],[a,b,c,f(d)]] ;"
  :mma "Table[MapAt[f,{a,b,c,d},i],{i,4}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(lambda( [[lambda_args]],  (-1*lambda_args[1]) ),[[a,b,c],[d,e,f]],[2,1]);
[[a,b,c],[-d,e,f]] ;"
  :mma "MapAt[-#&,{{a,b,c},{d,e,f}},{2,1}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(lambda( [[lambda_args]],  x ),[[a,b,c],[d,e,f]],[2,1]);
[[a,b,c],[x,e,f]] ;"
  :mma "MapAt[x&,{{a,b,c},{d,e,f}},{2,1}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(f,[a,[b,[d,e]],c],[2,2,0]);
[a,[b,f(d,e)],c] ;"
  :mma "MapAt[f,{a,{b,{d,e}},c},{2,2,0}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(f,[a,b,c],0);
f(a,b,c) ;"
  :mma "MapAt[f,{a,b,c},0]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(f,((x^2)+(y^2)),[[1,1],[2,1]]);
f(y)^2+f(x)^2 ;"
  :mma "MapAt[f,x^2 +y^2,{{1,1},{2,1}}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(f,(a+b+c+d),2);
d + c + f(b) + a ;"
  :mma "MapAt[f,a+b+c+d,2]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(h,[[a,b,c],[d,e],f,g],[[1,1],[2,2],[3]]);
[[h(a), b, c], [d, h(e)], h(f), g] ;"
  :mma "MapAt[h,{{a,b,c},{d,e},f,g},{{1,1},{2,2},{3}}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(h,[[a,b,c],[d,e],f,g],[[2],[1]]);
[h([a, b, c]), h([d, e]), f, g] ;"
  :mma "MapAt[h,{{a,b,c},{d,e},f,g},{{2},{1}}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(h,[[a,b,c],[d,e],f,g],[2,1]);
[[a, b, c], [h(d), e], f, g] ;"
  :mma "MapAt[h,{{a,b,c},{d,e},f,g},{2,1}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ni"
  :comments "count from the end"
  :maxin ""
  :maxout ""
  :mma "MapAt[h, {{a, b, c}, {d, e}, f, g}, -3]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(h,[[a,b,c],[d,e],f,g],2);
[[a, b, c], h([d, e]), f, g] ;"
  :mma "MapAt[h,{{a,b,c},{d,e},f,g},2]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(f,[[a,b,c],[d,e]],[2,1]);
[[a, b, c], [f(d), e]] ;"
  :mma "MapAt[f,{{a,b,c},{d,e}},{2,1}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(f,[a,b,c,d],[[1],[4]]);
[f(a), b, c, f(d)] ;"
  :mma "MapAt[f,{a,b,c,d},{{1},{4}}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(f,[a,b,c,d],2);
[a, f(b), c, d] ;"
  :mma "MapAt[f,{a,b,c,d},2]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :comments "negative indices supported"
  :maxin ""
  :maxout "MapAt(h,[[a,b,c],[d,e],f,g],-3);
[[a,b,c],h([d,e]),f,g] ;"
  :mma "MapAt[h,{{a,b,c},{d,e},f,g},-3]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Table(MapAt(f,[a,b,c,d],i),[i,4]);
[[f(a),b,c,d],[a,f(b),c,d],[a,b,f(c),d],[a,b,c,f(d)]] ;"
  :mma "Table[MapAt[f,{a,b,c,d},i],{i,4}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(lambda( [[lambda_args]],  (-1*lambda_args[1]) ),[[a,b,c],[d,e,f]],[2,1]);
[[a,b,c],[-d,e,f]] ;"
  :mma "MapAt[-#&,{{a,b,c},{d,e,f}},{2,1}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(lambda( [[lambda_args]],  x ),[[a,b,c],[d,e,f]],[2,1]);
[[a,b,c],[x,e,f]] ;"
  :mma "MapAt[x&,{{a,b,c},{d,e,f}},{2,1}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(f,[a,[b,[d,e]],c],[2,2,0]);
[a,[b,f(d,e)],c] ;"
  :mma "MapAt[f,{a,{b,{d,e}},c},{2,2,0}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(f,[a,b,c],0);
f(a,b,c) ;"
  :mma "MapAt[f,{a,b,c},0]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(f,((x^2)+(y^2)),[[1,1],[2,1]]);
f(y)^2+f(x)^2 ;"
  :mma "MapAt[f,x^2 +y^2,{{1,1},{2,1}}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(f,(a+b+c+d),2);
d + c + f(b) + a ;"
  :mma "MapAt[f,a+b+c+d,2]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(h,[[a,b,c],[d,e],f,g],[[1,1],[2,2],[3]]);
[[h(a), b, c], [d, h(e)], h(f), g] ;"
  :mma "MapAt[h,{{a,b,c},{d,e},f,g},{{1,1},{2,2},{3}}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(h,[[a,b,c],[d,e],f,g],[[2],[1]]);
[h([a, b, c]), h([d, e]), f, g] ;"
  :mma "MapAt[h,{{a,b,c},{d,e},f,g},{{2},{1}}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(h,[[a,b,c],[d,e],f,g],[2,1]);
[[a, b, c], [h(d), e], f, g] ;"
  :mma "MapAt[h,{{a,b,c},{d,e},f,g},{2,1}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ni"
  :comments "count from the end"
  :maxin ""
  :maxout ""
  :mma "MapAt[h, {{a, b, c}, {d, e}, f, g}, -3]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(h,[[a,b,c],[d,e],f,g],2);
[[a, b, c], h([d, e]), f, g] ;"
  :mma "MapAt[h,{{a,b,c},{d,e},f,g},2]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(f,[[a,b,c],[d,e]],[2,1]);
[[a, b, c], [f(d), e]] ;"
  :mma "MapAt[f,{{a,b,c},{d,e}},{2,1}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(f,[a,b,c,d],[[1],[4]]);
[f(a), b, c, f(d)] ;"
  :mma "MapAt[f,{a,b,c,d},{{1},{4}}]"
 ))

(help-item-add-example "MapAt"
  (list 
  :type "ok"
  :maxin ""
  :maxout "MapAt(f,[a,b,c,d],2);
[a, f(b), c, d] ;"
  :mma "MapAt[f,{a,b,c,d},2]"
 ))

(help-item-init "Decrement")

(help-item-add-example "Decrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((x:1),(y:3),(z:4),Decrement([x,y,[z]]));
[1, 3, [4]] ;"
  :mma "x=1;y=3;z=4;Decrement[{x,y,{z}}]"
 ))

(help-item-add-example "Decrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((y:a),(Decrement(y)-y));
1 ;"
  :mma "y=a;Decrement[y]-y"
 ))

(help-item-add-example "Decrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((y:a),Decrement(y));
a ;"
  :mma "y=a;Decrement[y]"
 ))

(help-item-add-example "Decrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "(Decrement(y)-y);
1 ;"
  :mma "Decrement[y]-y"
 ))

(help-item-add-example "Decrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((y:1),Decrement(y));
1 ;"
  :mma "y=1;Decrement[y]"
 ))

(help-item-add-example "Decrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "(kill(z), Decrement(z) );
z$"
  :mma "Decrement[z]"
 ))

(help-item-init "Append")

(help-item-add-example "Append"
  (list 
  :type "ok"
  :maxin "Append([a, b, c], [x, y]);"
  :maxout "[a,b,c,[x,y]];"
 ))

(help-item-add-example "Append"
  (list 
  :type "br"
  :maxin "NestList(lambda([y],Append(y,x)), [a], 5);"
  :maxout ""
 ))

(help-item-add-example "Append"
  (list 
  :type "br"
  :maxin "Map(lambda([y], Append(y, x)) , [[a, b], [c, d]]);"
  :maxout ""
 ))

(help-item-add-example "Append"
  (list 
  :type "ok"
  :maxin "map(lambda([y], Append(y, x)) , [[a, b], [c, d]]);"
  :maxout "[[a,b,x],[c,d,x]];"
 ))

(help-item-add-example "Append"
  (list 
  :type "ok"
  :maxin "Append(f[a, b, c], x + y);"
  :maxout "f[a,b,c,y+x];"
 ))

(help-item-add-example "Append"
  (list 
  :type "ok"
  :maxin "Append([a, b, c, d], x);"
  :maxout "[a,b,c,d,x];"
 ))

(help-item-init "Length")

(help-item-add-example "Length"
  (list 
  :type "ok"
  :maxin "Length(h[a,b](x,y,z));"
  :maxout "3;"
 ))

(help-item-add-example "Length"
  (list 
  :type "ok"
  :comments "Test succeeds but fails to agree with Mma, which  gives 2."
  :maxin "Length(sqrt(2));"
  :maxout "1;"
 ))

(help-item-add-example "Length"
  (list 
  :type "ok"
  :maxin "Length(IntegerDigits(1000!));"
  :maxout "2568;"
 ))

(help-item-add-example "Length"
  (list 
  :type "ok"
  :maxin "Length([ [a,b,c],[d,e,f]]);"
  :maxout "2;"
 ))

(help-item-add-example "Length"
  (list 
  :type "ok"
  :maxin "Length(3+%i);"
  :maxout "0;"
 ))

(help-item-add-example "Length"
  (list 
  :type "ok"
  :maxin "Length(1/10);"
  :maxout "0;"
 ))

(help-item-add-example "Length"
  (list 
  :type "ok"
  :maxin "Length(123456);"
  :maxout "0;"
 ))

(help-item-add-example "Length"
  (list 
  :type "ok"
  :maxin "Length(\"string\");"
  :maxout "0;"
 ))

(help-item-add-example "Length"
  (list 
  :type "ok"
  :comments "differs from Maxima"
  :maxin "Length(x);"
  :maxout "0;"
 ))

(help-item-add-example "Length"
  (list 
  :type "ok"
  :maxin "Length(f(g(x,y),z));"
  :maxout "2;"
 ))

(help-item-add-example "Length"
  (list 
  :type "ok"
  :maxin "Length(f[g[x,y],z]);"
  :maxout "2;"
 ))

(help-item-add-example "Length"
  (list 
  :type "ok"
  :maxin "Length(a+b+c+d);"
  :maxout "4;"
 ))

(help-item-add-example "Length"
  (list 
  :type "ok"
  :comments "Length is different than length in some cases"
  :maxin "Length([a,b,c,d]);"
  :maxout "4;"
 ))

(help-item-init "PreIncrement")

(help-item-add-example "PreIncrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((x:1),(y:3),(z:4),PreIncrement([x,y,[z]]));
[2, 4, [5]] ;"
  :mma "x=1;y=3;z=4;PreIncrement[{x,y,{z}}]"
 ))

(help-item-add-example "PreIncrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((y:a),(PreIncrement(y)-y));
0 ;"
  :mma "y=a;PreIncrement[y]-y"
 ))

(help-item-add-example "PreIncrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((y:a),PreIncrement(y));
a+1 ;"
  :mma "y=a;PreIncrement[y]"
 ))

(help-item-add-example "PreIncrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "(PreIncrement(y)-y);
0 ;"
  :mma "PreIncrement[y]-y"
 ))

(help-item-add-example "PreIncrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "((y:1),PreIncrement(y));
2 ;"
  :mma "y=1;PreIncrement[y]"
 ))

(help-item-add-example "PreIncrement"
  (list 
  :type "ok"
  :maxin ""
  :maxout "(kill(z), PreIncrement(z));
z+1$"
  :mma "PreIncrement[z]"
 ))

(help-item-init "PolynomialReduce")

(help-item-add-example "PolynomialReduce"
  (list 
  :type "ok"
  :maxin ""
  :maxout "PolynomialReduce(((x^3)+(y^3)),[((x^2)-(y^2)-1),(x+(Times(2,y)-7))],[x,y]);
[[x,y^2+1],-y^3+7*y^2-2*y+7] ;"
  :mma "PolynomialReduce[x^3 +y^3,{x^2 -y^2 -1,x+2 y-7},{x,y}]"
 ))

(help-item-init "Count")

(help-item-add-example "Count"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Count([a,a,a,b,b],c);
0 ;"
  :mma "Count[{a,a,a,b,b},c]"
 ))

(help-item-add-example "Count"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Count([a,a,a,b,b],b);
2 ;"
  :mma "Count[{a,a,a,b,b},b]"
 ))

(help-item-add-example "Count"
  (list 
  :type "ok"
  :maxin ""
  :maxout "Count([a,a,a,b,b],a);
3 ;"
  :mma "Count[{a,a,a,b,b},a]"
 ))

(help-item-init "Drop")

(help-item-add-example "Drop"
  (list 
  :type "ok"
  :comments "kind of works. different from Mma because of different default ordering.
 many other features of Drop, eg with levels are not implemented."
  :maxin "Drop(a + b + c + d + e + f, 3);"
  :maxout "c+b+a;"
 ))

(help-item-add-example "Drop"
  (list 
  :type "ok"
  :maxin "Drop([a, b, c, d, e, f], -3);"
  :maxout "[a,b,c];"
 ))

(help-item-add-example "Drop"
  (list 
  :type "ok"
  :maxin "Drop([a, b, c, d, e, f], 2);"
  :maxout "[c,d,e,f];"
 ))

